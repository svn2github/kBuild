# $Id$
## @file
#
# kBuild - File included at top of makefile.
#
# Copyright (c) 2004-2007 knut st. osmundsen <bird-kBuild-spam@anduin.net>
#
#
# This file is part of kBuild.
#
# kBuild is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version source of the License, or
# (at your option) any later version.
#
# kBuild is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with kBuild; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#

ifndef __footer_kmk__
# start-of-file-content
ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_FOOTER_START := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_FOOTER_START), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_FOOTER_START), $(_KBUILD_TS_PREV)) - start of footer.kmk)
 _KBUILD_TS_PREV := $(_KBUILD_TS_FOOTER_START)
endif

#
# Variables.
# (Some of these need initialization before including definitions using them.)
#

# All targets of each types.
_ALL_BLDPROGS    := $(BLDPROGS)    $(BLDPROGS.$(BUILD_PLATFORM))    $(BLDPROGS.$(BUILD_PLATFORM).$(BUILD_PLATFORM_ARCH))    $(BLDPROGS.$(BUILD_PLATFORM_ARCH))  $(BLDPROGS.$(BUILD_PLATFORM_CPU))   $(BLDPROGS.$(BUILD_TYPE))
_ALL_LIBRARIES   := $(LIBRARIES)   $(LIBRARIES.$(BUILD_TARGET))     $(LIBRARIES.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))       $(LIBRARIES.$(BUILD_TARGET_ARCH))   $(LIBRARIES.$(BUILD_TARGET_CPU))    $(LIBRARIES.$(BUILD_TYPE))
_ALL_IMPORT_LIBS := $(IMPORT_LIBS) $(IMPORT_LIBS.$(BUILD_TARGET))   $(IMPORT_LIBS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))     $(IMPORT_LIBS.$(BUILD_TARGET_ARCH)) $(IMPORT_LIBS.$(BUILD_TARGET_CPU))  $(IMPORT_LIBS.$(BUILD_TYPE))
_ALL_DLLS        := $(DLLS)        $(DLLS.$(BUILD_TARGET))          $(DLLS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))            $(DLLS.$(BUILD_TARGET_ARCH))        $(DLLS.$(BUILD_TARGET_CPU))         $(DLLS.$(BUILD_TYPE))
_ALL_PROGRAMS    := $(PROGRAMS)    $(PROGRAMS.$(BUILD_TARGET))      $(PROGRAMS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))        $(PROGRAMS.$(BUILD_TARGET_ARCH))    $(PROGRAMS.$(BUILD_TARGET_CPU))     $(PROGRAMS.$(BUILD_TYPE))
_ALL_SYSMODS     := $(SYSMODS)     $(SYSMODS.$(BUILD_TARGET))       $(SYSMODS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))         $(SYSMODS.$(BUILD_TARGET_ARCH))     $(SYSMODS.$(BUILD_TARGET_CPU))      $(SYSMODS.$(BUILD_TYPE))
_ALL_OTHERS      := $(OTHERS)      $(OTHERS.$(BUILD_TARGET))        $(OTHERS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))          $(OTHERS.$(BUILD_TARGET_ARCH))      $(OTHERS.$(BUILD_TARGET_CPU))       $(OTHERS.$(BUILD_TYPE))
_ALL_INSTALLS    := $(INSTALLS)    $(INSTALLS.$(BUILD_TARGET))      $(INSTALLS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))        $(INSTALLS.$(BUILD_TARGET_ARCH))    $(INSTALLS.$(BUILD_TARGET_CPU))     $(INSTALLS.$(BUILD_TYPE))
_ALL_FETCHES     := $(FETCHES)     $(FETCHES.$(BUILD_TARGET))       $(FETCHES.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))         $(FETCHES.$(BUILD_TARGET_ARCH))     $(FETCHES.$(BUILD_TARGET_CPU))      $(FETCHES.$(BUILD_TYPE))
_ALL_PATCHES     := $(PATCHES)     $(PATCHES.$(BUILD_TARGET))       $(PATCHES.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))         $(PATCHES.$(BUILD_TARGET_ARCH))     $(PATCHES.$(BUILD_TARGET_CPU))      $(PATCHES.$(BUILD_TYPE))

# all targets.
_ALL_TARGETS = \
	$(_ALL_FETCHES) \
	$(_ALL_PATCHES) \
	$(_ALL_BLDPROGS) \
	$(_ALL_LIBRARIES) \
	$(_ALL_IMPORT_LIBS) \
	$(_ALL_DLLS) \
	$(_ALL_PROGRAMS) \
	$(_ALL_SYSMODS) \
	$(_ALL_INSTALLS) \
	$(_ALL_OTHERS)

# all $(BUILD_TARGET) targets.
_ALL_BUILD_TARGET_TARGETS = \
	$(_ALL_FETCHES) \
	$(_ALL_PATCHES) \
	$(_ALL_LIBRARIES) \
	$(_ALL_IMPORT_LIBS) \
	$(_ALL_DLLS) \
	$(_ALL_PROGRAMS) \
	$(_ALL_SYSMODS) \
	$(_ALL_INSTALLS) \
	$(_ALL_OTHERS)

# all $(BUILD_PLATFORM) targets.
_ALL_BUILD_PLATFORM_TARGETS = \
	$(_ALL_BLDPROGS)

# all targets making use of srcname.
_ALL_SRCNAME_TARGETS = \
	$(_ALL_FETCHES) \
	$(_ALL_PATCHES)

# dependency files.
_DEPFILES :=

# included dependency files.
_DEPFILES_INCLUDED :=


# All kind of output files except for _OBJS and _DEPFILES.
# Compiling or linking definition outputting other things that $@ and any
# required dependency file must add those output files to this variable.
_OUT_FILES :=

# Files which only requires cleaning up.
_CLEAN_FILES :=

# all of a type
_OBJS     :=
_FETCHES  :=
_DOWNLOADS:=
_UNPACKS  :=
_PATCHES  :=
_UNFETCHES:=
_BLDPROGS :=
_LIBS     :=
_DLLS     :=
_PROGRAMS :=
_SYSMODS  :=
_INSTALLS :=
_INSTALLS_FILES :=
_INSTALLS_DIRS :=
_OTHERS   :=
_PACKING  :=
_DIRS     := $(PATH_TARGET)/ $(PATH_TARGET) $(BLDDIRS)
_IMPORT_LIBS :=

# misc
pass_prev :=



#
# Footer macros
#

## Figure out the tool for a target.
# @param    $1           normalized target.
# @param    $2           tooltype.
# @param    bld_trg      build target.
# @param    bld_trg_arch build target architecture.
_TARGET_TOOL = $(strip $(firstword \
	$($(1)_$(2)TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(1)_$(2)TOOL.$(bld_trg)) \
	$($(1)_$(2)TOOL) \
	$($(1)_TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(1)_TOOL.$(bld_trg)) \
	$($(1)_TOOL) \
	$($(2)TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(2)TOOL.$(bld_trg)) \
	$($(2)TOOL) \
	$(TOOL.$(bld_trg).$(bld_trg_arch)) \
	$(TOOL.$(bld_trg)) \
	$(TOOL) \
	))

## Figure out the actual name of an installed file.
# @param	$1		The file to install.
# @param	$2		The target name.
# @param	$3		The _INST value (can be empty).
# @param	$4		The default directory to use when $3 is empty.
_INSTALL_FILE = $(patsubst %/,%/$(notdir $(1)),$(if $(3),$(PATH_INS)/$(3),$(4)/))


## Inherit one template property in a non-accumulative manner.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
# @remark Not all properties has all the variations, but making the correct
#         exceptions will only complicate matters and probably not gain much speed.
define def_inherit_one
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $($(src)_$(prop))
  #$ (warning dbg-inherit: $(trg)_$(prop) = $($(src)_$(prop)) )
 endif
endif
endef # def_inherit_one

## Inherit one template property in a non-accumulative manner.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
# @remark Not all properties has all the variations, but making the correct
#         exceptions will only complicate matters and probably not gain much speed.
# @todo   Check how/if this differs from def_inherit_one.
define def_inherit_one_now
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) := $($(src)_$(prop))
  #$ (warning dbg-inherit-now: $(trg)_$(prop) = $($(src)_$(prop)) )
 endif
endif
endef # def_inherit_one_now

## Inherit one template property in a non-accumulative manner, deferred expansion.
# @param    $(prop)         Property name
# @param    $(src)          Source
# @param    $(trg)          Target
# @remark This define relies on double evaluation
define def_inherit_one_deferred
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $$($(src)_$(prop))
  #$ (warning dbg-inherit-def: $(trg)_$(prop) = $($(src)_$(prop)) )
 endif
endif
endef # def_inherit_one_deferred

## Generic inheritance for use with targets templates and tools.
# @param    trg                 Object to consider for inheriting.
# @param    src_prefix          What to prefix the value found in EXTENDS with to get the object.
# @param    properties          List of the properties with straight expansion.
# @param    properties_now      List of the properties with immediate expansion.
# @param    properties_deferred List of the properties with deferred expansion (e.g. function).
define def_inherit
src := $(strip $($(trg)_EXTENDS))
ifneq ($(src),)
 ifndef $(trg)_EXTENDS_STATUS_
  $(trg)_EXTENDS_STATUS_ := 0
  src := $(src_prefix)$(src)

  # Recursivly process the parent (src) if it's inherting from somebody too.
  ifdef $(src)_EXTENDS
   ifneq ($($(src)_EXTENDS_STATUS_),42)
    # 'foreach' will create 'trg' in a new variable context hiding
	# out current variable. 'src' OTOH will be overwritten.
    #$ (warning def_inherit: recursing into $(src) from $(trg))
    $(foreach trg, $(src), $(eval $(value def_inherit)))
    src := $(src_prefix)$(strip $($(trg)_EXTENDS))
   endif
  endif

  # Inherit the properties and mark the trg done.
  #$ (warning def_inherit: trg=$(trg) src=$(src))
  $(foreach prop, $(properties),          $(eval $(def_inherit_one)))
  $(foreach prop, $(properties_now),      $(eval $(def_inherit_one_now)))
  $(foreach prop, $(properties_deferred), $(eval $(def_inherit_one_deferred)))
  $(trg)_EXTENDS_STATUS_ := 42
 else
  # Check for inheritance loops.
  ifneq ($($(trg)_EXTENDS_STATUS_),42)
   $(error kBuild: Target inheritance loop! target=$(trg) $(trg)_EXTENDS_STATUS_=$($(trg)_EXTENDS_STATUS_))
  endif
 endif
endif
endef # def_inherit


#
# Determin all the templates that is being used and make
# sure they are present.
#
_TEMPLATES := $(TEMPLATE)
define def_templates
ifdef $(target)_TEMPLATE
 ifneq ("$($(target)_TEMPLATE)","$(strip $($(target)_TEMPLATE))")
  $$(error kBuild: The template name of target '$(target)' contains tabs ($($(target)_TEMPLATE))). Please remove them)
 endif
 _TEMPLATES += $($(target)_TEMPLATE)
endif
endef # def_templates
$(foreach target, $(_ALL_TARGETS), $(eval $(def_templates)))
_TEMPLATES := $(sort $(_TEMPLATES))

define def_templates_include
ifndef TEMPLATE_$(template)
 TEMPLATE_$(template)_INCLUDE_FILE_ := $(firstword $(foreach path, $(TEMPLATE_PATHS) $(PATH_KBUILD)/templates/, $(wildcard $(path)/$(template).kmk)))
 ifneq ($(TEMPLATE_$(template)_INCLUDE_FILE_),)
  include $(TEMPLATE_$(template)_INCLUDE_FILE_)
 else
  $$(error kBuild: Cannot find template '$(template)')
 endif
endif
endef # def_templates_include
$(foreach template, $(_TEMPLATES), $(eval $(def_templates_include)))

#$ (warning dbg _TEMPLATES := $(_TEMPLATES))


#
# Determin the BLD_TRG_* keywords required for correct inherting.
#
# This means walking all the template and target lists in order to
# pick up all BLD_TRG_* attributes.
#
_BLD_TYPES   := $(BUILD_TYPE)
_BLD_TARGETS := $(BUILD_TARGET) $(BUILD_PLATFORMS)
_BLD_ARCHES  := $(BUILD_TARGET_ARCH) $(BUILD_PLATFORM_ARCH)
_BLD_CPUS    := $(BUILD_TARGET_CPU) $(BUILD_PLATFORM_CPU)

define def_collect_bld_xyz
ifdef ($(src)_BLD_TYPE)
 _BLD_TYPE += $($(src)_BLD_TYPE)
endif
ifdef ($(src)_BLD_TRG)
 _BLD_TARGETS += $($(src)_BLD_TRG)
endif
ifdef ($(src)_BLD_TRG_ARCH)
 _BLD_ARCHES += $($(src)_BLD_TRG_ARCH)
endif
ifdef ($(src)_BLD_TRG_CPU)
 _BLD_CPU += $($(src)_BLD_TRG_CPU)
endif
endef # def_collect_bld_xyz
$(foreach src, $(addprefix TEMPLATE_, $(_TEMPLATES)) $(_ALL_TARGETS)\
	,$(eval $(def_collect_bld_xyz)))

# drop duplicate values
_BLD_TYPES   := $(sort $(_BLD_TYPES))
_BLD_TARGETS := $(sort $(_BLD_TARGETS))
_BLD_ARCHES  := $(sort $(_BLD_ARCHES))
_BLD_CPUS    := $(sort $(_BLD_CPUS))

# Construct all the possible keywords.
_KEYWORDS := $(_BLD_TYPES) $(_BLD_TARGETS) $(_BLD_ARCHES) $(_BLD_CPUS) \
	$(foreach bld_trg,$(_BLD_TARGETS),$(addprefix $(bld_trg).,$(_BLD_ARCHES)))
# $ (warning dbg _KEYWORDS := $(_KEYWORDS))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done keywords)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# Target inheritance.
#
# This has to be done on a per target list basis as to avoid adding
# incorrect properties that will wast memory, time, and may confuse
# later strictness checks. This also has to be done *before* templates
# are applied to the targets. Since we're doing that part rather
# early on, the target inheritance feature is a bit restricted at
# the moment. However, this will be addressed in a little(?) while.
#

src_prefix :=
## combines the specified properties $(1) with the $(_KEYWORDS).
_COMB_KEY_PROP = $(1)  $(foreach keyword,$(_KEYWORDS), $(addsuffix .$(keyword), $(1)))

# Fetches.
properties          := $(call _COMB_KEY_PROP,$(PROPS_FETCHES_SINGLE))
properties_now      := $(call _COMB_KEY_PROP,$(PROPS_FETCHES_ACCUMULATE_R) $(PROPS_FETCHES_ACCUMULATE_L))
properties_deferred := $(call _COMB_KEY_PROP,$(PROPS_FETCHES_DEFERRED))
$(foreach trg, $(_ALL_FETCHES),$(eval $(value def_inherit)))

## Patches. - not implemented yet.
#properties          := $(call _COMB_KEY_PROP,$(PROPS_PATCHES_SINGLE))
#properties_now      := $(call _COMB_KEY_PROP,$(PROPS_PATCHES_ACCUMULATE_R) $(PROPS_PATCHES_ACCUMULATE_L))
#properties_deferred := $(call _COMB_KEY_PROP,$(PROPS_PATCHES_DEFERRED))
#$(foreach trg, $(_ALL_PATCHES),$(eval $(value def_inherit)))

# Programs and build programs.
properties          := $(call _COMB_KEY_PROP,$(PROPS_PROGRAMS_SINGLE))
properties_now      := $(call _COMB_KEY_PROP,$(PROPS_PROGRAMS_ACCUMULATE_R) $(PROPS_PROGRAMS_ACCUMULATE_L))
properties_deferred := $(call _COMB_KEY_PROP,$(PROPS_PROGRAMS_DEFERRED))
$(foreach trg, $(_ALL_BLDPROGS) $(_ALL_PROGRAMS),$(eval $(value def_inherit)))

# Libraries and import libraries.
properties          := $(call _COMB_KEY_PROP,$(PROPS_LIBRARIES_SINGLE))
properties_now      := $(call _COMB_KEY_PROP,$(PROPS_LIBRARIES_ACCUMULATE_R) $(PROPS_LIBRARIES_ACCUMULATE_L))
properties_deferred := $(call _COMB_KEY_PROP,$(PROPS_LIBRARIES_DEFERRED))
ifeq ($(filter-out nt os2 win win64 win32,$(BUILD_TARGET)),)
 $(foreach trg, $(_ALL_LIBRARIES) $(_ALL_IMPORT_LIBS),$(eval $(value def_inherit)))
else
 $(foreach trg, $(_ALL_LIBRARIES),$(eval $(value def_inherit)))
endif

# DLLs.
properties          := $(call _COMB_KEY_PROP,$(PROPS_DLLS_SINGLE))
properties_now      := $(call _COMB_KEY_PROP,$(PROPS_DLLS_ACCUMULATE_R) $(PROPS_DLLS_ACCUMULATE_L))
properties_deferred := $(call _COMB_KEY_PROP,$(PROPS_DLLS_DEFERRED))
ifeq ($(filter-out nt os2 win win64 win32,$(BUILD_TARGET)),)
 $(foreach trg, $(_ALL_DLLS),$(eval $(value def_inherit)))
else
 $(foreach trg, $(_ALL_DLLS) $(_ALL_IMPORT_LIBS),$(eval $(value def_inherit)))
endif

# System modules.
properties          := $(call _COMB_KEY_PROP,$(PROPS_SYSMODS_SINGLE))
properties_now      := $(call _COMB_KEY_PROP,$(PROPS_SYSMODS_ACCUMULATE_R) $(PROPS_SYSMODS_ACCUMULATE_L))
properties_deferred := $(call _COMB_KEY_PROP,$(PROPS_SYSMODS_DEFERRED))
$(foreach trg, $(_ALL_SYSMODS),$(eval $(value def_inherit)))

# Installs.
properties          := $(call _COMB_KEY_PROP,$(PROPS_INSTALLS_SINGLE))
properties_now      := $(call _COMB_KEY_PROP,$(PROPS_INSTALLS_ACCUMULATE_R) $(PROPS_INSTALLS_ACCUMULATE_L))
properties_deferred := $(call _COMB_KEY_PROP,$(PROPS_INSTALLS_DEFERRED))
$(foreach trg, $(_ALL_INSTALLS),$(eval $(value def_inherit)))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done target inheritance)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# Template Inheritance.
#
# This is much the same as with target inheritance, except we cannot
# restrict the properties involved since we haven't got a clue which
# target platforms/archs are using them. But, we can drop the instance
# expansion we're doing for targets since there won't be any more
# changes to either the source nor the target templates beyond this
# exercise.
#

src_prefix := TEMPLATE_
properties :=
properties_now :=
properties_deferred := $(call _COMB_KEY_PROP,$(PROPS_ALL))
$(foreach trg, $(addprefix TEMPLATE_,$(_TEMPLATES)),$(eval $(value def_inherit)))

# done.
src_prefix :=
properties :=
properties_now :=
properties_deferred :=

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done template inheritance)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# Common Inheritance
#

## Inherit one template property in a non-accumulative manner.
# @param    $(prop)     Property name
# @param    $(target)	Target name
# @todo fix the precedence order for some properties.
define def_inherit_template_one
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop)
ifndef $(target)_$(prop)
$(target)_$(prop) := $(TEMPLATE_$($(target)_TEMPLATE)_$(prop))
#$ (warning dbgtarget: $(target)_$(prop):='$(value $(target)_$(prop))' TEMPLATE_$($(target)_TEMPLATE)_$(prop))
endif
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg)
ifndef $(target)_$(prop).$(bld_trg)
#$ (warning dbgsource: $(target)_$(prop).$(bld_trg)="TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg)" TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg))
$(target)_$(prop).$(bld_trg) := $(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg))
endif
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch)
ifndef $(target)_$(prop).$(bld_trg).$(bld_trg_arch)
#$ (warning dbgsource: $(target)_$(prop).$(bld_trg).$(bld_trg_arch)="TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch)" TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch))
$(target)_$(prop).$(bld_trg).$(bld_trg_arch) := $(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch))
endif
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch)
ifndef $(target)_$(prop).$(bld_trg_arch)
#$ (warning dbgsource: $(target)_$(prop).$(bld_trg_arch)="TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch)" TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch))
$(target)_$(prop).$(bld_trg_arch) := $(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch))
endif
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu)
ifndef $(target)_$(prop).$(bld_trg_cpu)
#$ (warning dbgsource: $(target)_$(prop).$(bld_trg_cpu)="TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu)" TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu))
$(target)_$(prop).$(bld_trg_cpu) := $(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu))
endif
endif
endef

## Inherit one template property in a non-accumulative manner, deferred expansion.
# @param    1: $(prop)     Property name
# @param    2: $(target)	Target name
# @todo fix the precedence order for some properties.
# @remark this define relies on double evaluation
define def_inherit_template_one_deferred
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop)
ifndef $(target)_$(prop)
$(target)_$(prop) = $$(TEMPLATE_$($(target)_TEMPLATE)_$(prop))
#$ (warning dbgtarget: $(target)_$(prop):='$(value $(target)_$(prop))' TEMPLATE_$($(target)_TEMPLATE)_$(prop))
endif
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg)
ifndef $(target)_$(prop).$(bld_trg)
#$ (warning dbgsource: $(target)_$(prop).$(bld_trg)="TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg)" TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg))
$(target)_$(prop).$(bld_trg) = $$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg))
endif
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch)
ifndef $(target)_$(prop).$(bld_trg).$(bld_trg_arch)
#$ (warning dbgsource: $(target)_$(prop).$(bld_trg).$(bld_trg_arch)="TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch)" TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch))
$(target)_$(prop).$(bld_trg).$(bld_trg_arch) = $$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch))
endif
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch)
ifndef $(target)_$(prop).$(bld_trg_arch)
#$ (warning dbgsource: $(target)_$(prop).$(bld_trg_arch)="TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch)" TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch))
$(target)_$(prop).$(bld_trg_arch) = $$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch))
endif
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu)
ifndef $(target)_$(prop).$(bld_trg_cpu)
#$ (warning dbgsource: $(target)_$(prop).$(bld_trg_cpu)="TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu)" TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu))
$(target)_$(prop).$(bld_trg_cpu) = $$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu))
endif
endif
endef

## Inherit one acculumlative template property where the 'most significant' items are at the left end.
# @param    $(prop)     Property name
# @param    $(target)	Target name
define def_inherit_template_one_accumulate_l
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop)
#$ (warning dbgtype: TEMPLATE_$($(target)_TEMPLATE)_$(prop) $(target)_$(prop)=$($(target)_$(prop)) $(TEMPLATE_$($(target)_TEMPLATE)_$(prop)))
$(target)_$(prop) += $$(TEMPLATE_$($(target)_TEMPLATE)_$(prop))
#$ (warning dbgtype: $(target)_$(prop)=$($(target)_$(prop)))
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(BUILD_TYPE)
#$ (warning dbg4: TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(BUILD_TYPE))
$(target)_$(prop).$(BUILD_TYPE) += $$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(BUILD_TYPE))
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg)
#$ (warning dbg5: TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg))
$(target)_$(prop).$(bld_trg) += $$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg))
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch)
#$ (warning dbg4: TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch))
$(target)_$(prop).$(bld_trg).$(bld_trg_arch) += $$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch))
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu)
#$ (warning dbg5: TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu))
$(target)_$(prop).$(bld_trg_cpu) += $$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu))
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch)
#$ (warning dbg6: TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch))
$(target)_$(prop).$(bld_trg_arch) += $$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch))
endif
endef

## Inherit one acculumlative template property where the 'most significant' items are at the right end.
# @param    $(prop)     Property name
# @param    $(target)	Target name
define def_inherit_template_one_accumulate_r
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop)
#$ (warning dbgtype: TEMPLATE_$($(target)_TEMPLATE)_$(prop) $(target)_$(prop)=$($(target)_$(prop)) $(TEMPLATE_$($(target)_TEMPLATE)_$(prop)))
$(target)_$(prop) <=$$(TEMPLATE_$($(target)_TEMPLATE)_$(prop))
#$ (warning dbgtype: $(target)_$(prop)=$($(target)_$(prop)))
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(BUILD_TYPE)
#$ (warning dbg4: TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(BUILD_TYPE))
$(target)_$(prop).$(BUILD_TYPE) <=$$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(BUILD_TYPE))
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg)
#$ (warning dbg5: TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg))
$(target)_$(prop).$(bld_trg) <=$$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg))
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch)
#$ (warning dbg4: TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch))
$(target)_$(prop).$(bld_trg).$(bld_trg_arch) <=$$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg).$(bld_trg_arch))
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu)
#$ (warning dbg5: TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu))
$(target)_$(prop).$(bld_trg_cpu) <=$$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_cpu))
endif
ifdef TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch)
#$ (warning dbg6: TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch))
$(target)_$(prop).$(bld_trg_arch) <=$$(TEMPLATE_$($(target)_TEMPLATE)_$(prop).$(bld_trg_arch))
endif
endef


## Inherit template properties for on target.
# @param    $(target)    Target name.
define def_inherit_template
# sanity check.
ifdef _$(target)_ALREADY_PROCESSED
 $(error kBuild: The target $(target) appears more than once in the target lists! Please correct the makefile(s))
endif
_$(target)_ALREADY_PROCESSED := 1

# Inherit any default template.
ifdef TEMPLATE
ifeq ($($(target)_TEMPLATE),)
$(eval $(target)_TEMPLATE:=$(TEMPLATE))
endif
endif
# Expand the template if specified.
ifneq ($($(target)_TEMPLATE),)
$(foreach prop,$(PROPS_SINGLE),$(eval $(value def_inherit_template_one)))
$(foreach prop,$(PROPS_DEFERRED),$(eval $(def_inherit_template_one_deferred))) # exploits the 2 evaluation, so no value!
$(foreach prop,$(PROPS_ACCUMULATE_L),$(eval $(def_inherit_template_one_accumulate_l))) # += works fine without value
$(foreach prop,$(PROPS_ACCUMULATE_R),$(eval $(def_inherit_template_one_accumulate_r))) # use <= (kmk addition)
endif
endef

# Inherit template properties
bld_trg := $(BUILD_TARGET)
bld_trg_arch := $(BUILD_TARGET_ARCH)
bld_trg_cpu := $(BUILD_TARGET_CPU)
$(foreach target, $(_ALL_BUILD_TARGET_TARGETS),$(eval $(value def_inherit_template)))

bld_trg := $(BUILD_PLATFORM)
bld_trg_arch := $(BUILD_PLATFORM_ARCH)
bld_trg_cpu := $(BUILD_PLATFORM_CPU)
$(foreach target, $(_ALL_BUILD_PLATFORM_TARGETS),$(eval $(value def_inherit_template)))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done common inheritance)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# Include tools & sdks
#
# The first part of this exercise is to figure out which TOOLS and SDKS
# that should be included.
#
_TOOLS := $(TOOL.$(BUILD_TARGET))   $(TOOL.$(BUILD_TARGET_ARCH))   $(TOOL.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)) \
          $(TOOL.$(BUILD_PLATFORM)) $(TOOL.$(BUILD_PLATFORM_ARCH)) $(TOOL.$(BUILD_PLATFORM).$(BUILD_PLATFORM_ARCH)) \
	  $(TOOL)
_SDKS  := $(SDKS.$(BUILD_TARGET))   $(SDKS.$(BUILD_TARGET_ARCH))   $(SDKS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)) \
          $(SDKS.$(BUILD_PLATFORM)) $(SDKS.$(BUILD_PLATFORM_ARCH)) $(SDKS.$(BUILD_PLATFORM).$(BUILD_PLATFORM_ARCH)) \
	  $(SDKS.$(BUILD_TYPE)) \
	  $(SDKS)
define def_tools_sdks_target_source
$(eval _TOOLS += $(foreach prop, $(PROPS_TOOLS), \
	$($(source)_$(prop).$(_bld_trg)) \
	$($(target)_$(source)_$(prop).$(_bld_trg)) \
	$($(source)_$(prop).$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_$(source)_$(prop).$(_bld_trg).$(_bld_trg_arch)) \
	$($(source)_$(prop).$(_bld_trg_arch)) \
	$($(target)_$(source)_$(prop).$(_bld_trg_arch)) \
	$($(source)_$(prop)) \
	$($(target)_$(source)_$(prop))))
$(eval _SDKS += \
	$($(source)_SDKS.$(_bld_trg)) \
	$($(target)_$(source)_SDKS.$(_bld_trg)) \
	$($(source)_SDKS.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_$(source)_SDKS.$(_bld_trg).$(_bld_trg_arch)) \
	$($(source)_SDKS.$(_bld_trg_arch)) \
	$($(target)_$(source)_SDKS.$(_bld_trg_arch)) \
	$($(source)_SDKS.$(BUILD_TYPE)) \
	$($(target)_$(source)_SDKS.$(BUILD_TYPE)) \
	$($(source)_SDKS) \
	$($(target)_$(source)_SDKS))
endef # def_tools_sdks_target_source

define def_tools_sdks_target
_bld_type := $(firstword $($(target)_BLD_TYPE) $(BUILD_TYPE))
_bld_trg := $(firstword $($(target)_BLD_TRG) $(bld_trg))
_bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(bld_trg_arch))
_bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU) $(bld_trg_cpu))

$(eval _TOOLS += $(foreach prop, $(PROPS_TOOLS), \
	$($(target)_$(prop).$(_bld_trg)) \
	$($(target)_$(prop).$(_bld_trg_arch)) \
	$($(target)_$(prop).$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_$(prop))))
$(eval _SDKS += \
	$($(target)_SDKS.$(_bld_trg)) \
	$($(target)_SDKS.$(_bld_trg_arch)) \
	$($(target)_SDKS.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_SDKS))
$(foreach source, \
	$($(target)_SOURCES.$(_bld_trg)) \
	$($(target)_SOURCES.$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg_cpu)) \
	$($(target)_SOURCES.$(_bld_type)) \
	$($(target)_SOURCES) \
	, $(eval $(value def_tools_sdks_target_source)))
endef # def_tools_sdks_target

define def_tools_srcname_target
_bld_type := $(firstword $($(target)_BLD_TYPE) $(BUILD_TYPE))
_bld_trg := $(firstword $($(target)_BLD_TRG) $(bld_trg))
_bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(bld_trg_arch))
_bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU) $(bld_trg_cpu))

$(foreach source, $(notdir\
	$($(target)_SOURCES.$(_bld_trg)) \
	$($(target)_SOURCES.$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg_cpu)) \
	$($(target)_SOURCES.$(_bld_type)) \
	$($(target)_SOURCES) \
	), $(eval $(value def_tools_sdks_target_source)))
endef # def_tools_srcname_target

bld_trg := $(BUILD_TARGET)
bld_trg_arch := $(BUILD_TARGET_ARCH)
bld_trg_cpu := $(BUILD_TARGET_CPU)
$(foreach target, $(_ALL_BUILD_TARGET_TARGETS), $(eval $(value def_tools_sdks_target)))
$(foreach target, $(_ALL_SRCNAME_TARGETS), $(eval $(value def_tools_srcname_target)))

bld_trg := $(BUILD_PLATFORM)
bld_trg_arch := $(BUILD_PLATFORM_ARCH)
bld_trg_cpu := $(BUILD_PLATFORM_CPU)
$(foreach target, $(_ALL_BUILD_PLATFORM_TARGETS), $(eval $(value def_tools_sdks_target)))


# include TOOLS
define def_tools_include
ifndef TOOL_$(tool)
 TOOL_$(tool)_KMK_FILE := $(firstword $(foreach path, $(TOOL_PATHS) $(PATH_KBUILD)/tools, $(wildcard $(path)/$(tool).kmk)))
 ifeq ($(TOOL_$(tool)_KMK_FILE),)
  $(error kBuild: Cannot find include file for the tool '$(tool)'! Searched: $(TOOL_PATHS) $(PATH_KBUILD)/tools)
 endif
 include $(TOOL_$(tool)_KMK_FILE)
 ifndef TOOL_$(tool)
  $(warning kBuild: TOOL_$(tool) was not by $(TOOL_$(tool)_KMK_FILE)!)
 endif
endif
endef # def_tools_include

_TOOLS := $(sort $(_TOOLS))
$(foreach tool, $(_TOOLS), $(eval $(value def_tools_include)))


# include SDKS
define def_sdks_include_one
ifndef SDK_$(sdk)
 SDK_$(sdk)_KMK_FILE := $(firstword $(foreach path, $(SDK_PATHS) $(PATH_KBUILD)/sdks, $(wildcard $(path)/$(sdk).kmk)))
 ifeq ($(SDK_$(sdk)_KMK_FILE),)
  $(error kBuild: Cannot find include file for the SDK '$(sdk)'! Searched: $(SDK_PATHS) $(PATH_KBUILD)/sdks)
 endif
 include $(SDK_$(sdk)_KMK_FILE)
 ifndef SDK_$(sdk)
  $(warning kBuild: SDK_$(sdk) was not defined by $(SDK_$(sdk)_KMK_FILE)!)
 endif
endif
endef # def_sdks_include_one

_SDKS := $(sort $(_SDKS))
$(foreach sdk, $(_SDKS), $(eval $(value def_sdks_include_one)))

## @todo Execute SDKS and TOOL inhertiance.

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done tools and sdks)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
#
# Target lists - Pass 1
#
#       This pass is for defining variables that might be referenced in
#       properties of other targets.
#
#

# Don't do anything for fetch targets (yet).

##
# Link prolog for Pass 1.
#
# @param    $(target)           Normalized target name.
# @param    $(EXT)              EXE,DLL,SYS,LIB.
# @param    $(EXTPRE)           HOST or nothing.
# @param    $(definst)          The default _INST value.
# @param    $(tool_prefix)      LD or AR.
# @param    $(bld_trg_base_var) TARGET or PLATFORM.
define def_pass1_link_common

bld_type    := $(firstword $($(target)_BLD_TYPE)     $(BUILD_TYPE))
bld_trg     := $(firstword $($(target)_BLD_TRG)      $(BUILD_$(bld_trg_base_var)))
bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(BUILD_$(bld_trg_base_var)_ARCH))
bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(BUILD_$(bld_trg_base_var)_CPU))

tool        := $(call _TARGET_TOOL,$(target),$(tool_prefix))
name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
outbase     := $(call TARGET_BASE,$(name),$(target))
ifndef PATH_$(target)
 PATH_$(target) := $(patsubst %/,%,$(dir $(outbase)))
else ifneq ($(PATH_$(target)),$(patsubst %/,%,$(dir $(outbase))))
  $(error kBuild internal error: PATH_$(target)=$(PATH_$(target)) expected $(patsubst %/,%,$(dir $(outbase))))
endif
ifeq ($(tool_prefix),AR) ## @todo fix this mess!
suff := $(firstword\
	$($(target)_$(EXT)SUFF.$(bld_trg).$(bld_trg_arch))\
	$($(target)_$(EXT)SUFF.$(bld_trg))\
	$($(target)_$(EXT)SUFF)\
	$(TOOL_$(tool)_$(tool_prefix)$(EXT)SUFF.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_$(tool_prefix)$(EXT)SUFF.$(bld_trg))\
	$(TOOL_$(tool)_$(tool_prefix)$(EXT)SUFF)\
	$(SUFF_LIB))
else
suff := $(firstword \
	$($(target)_$(EXT)SUFF) \
	$($(target)_$(EXT)SUFF) \
	$(TOOL_$(tool)_$(tool_prefix)$(EXT)SUFF) \
	$($(EXTPRE)SUFF_$(EXT)))
endif
out := $(outbase)$(suff)

# TARGET_*
TARGET_$(target) := $(out)

# INSTARGET_*
ifndef $(target)_NOINST
INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)), \
	$(if $($(target)_INST), $(addprefix $(PATH_INS)/,$($(target)_INST)), $(definst)/))

else # NOINST
INSTARGET_$(target) :=
endif # NOINST

endef


#
# BLDPROGS (Pass 1)
#
define def_pass1_bldprog
# set NOINST if not forced installation before doing the usual stuff.
ifndef $(target)_INST
$(target)_NOINST := 1
endif
$(eval $(value def_pass1_link_common))
endef

EXT     := EXE
EXTPRE  := HOST
definst := $(PATH_BIN)
tool_prefix := LD
bld_trg_base_var := PLATFORM
$(foreach target, $(BLDPROGS) $(BLDPROGS.$(BUILD_PLATFORM)) $(BLDPROGS.$(BUILD_PLATFORM).$(BUILD_PLATFORM_ARCH)), \
	$(eval $(value def_pass1_bldprog)))


#
# LIBRARIES (Pass 1)
#
EXT     := LIB
EXTPRE  :=
definst := $(PATH_LIB)
tool_prefix := AR
bld_trg_base_var := TARGET
$(foreach target, $(LIBRARIES) $(LIBRARIES.$(BUILD_TARGET)) $(LIBRARIES.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), \
	$(eval $(value def_pass1_link_common)))


#
# DLLS  (Pass 1)
#
EXT     := DLL
EXTPRE  :=
definst := $(PATH_DLL)
tool_prefix := LD
bld_trg_base_var := TARGET
$(foreach target, $(DLLS) $(DLLS.$(BUILD_TARGET)) $(DLLS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), \
	$(eval $(value def_pass1_link_common)))


#
# IMPORT LIBRARIES (Pass 1)
#
#   - On OS/2 and windows these are libraries.
#   - On other platforms they are fake DLLs.
#
if1of ($(BUILD_TARGET), nt os2 win win64 win32)
 EXT     := LIB
 EXTPRE  :=
 definst := $(PATH_LIB)
 tool_prefix := AR
 bld_trg_base_var := TARGET
 $(foreach target, $(IMPORT_LIBS) $(IMPORT_LIBS.$(BUILD_TARGET)) $(IMPORT_LIBS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), \
	$(eval $(value def_pass1_link_common)))
else
 EXT     := DLL
 EXTPRE  :=
 definst := $(PATH_DLL)
 tool_prefix := LD
 bld_trg_base_var := TARGET
 $(foreach target, $(IMPORT_LIBS) $(IMPORT_LIBS.$(BUILD_TARGET)) $(IMPORT_LIBS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), \
	$(eval $(value def_pass1_link_common)))
endif


#
# PROGRAMS (Pass 1)
#
EXT     := EXE
EXTPRE  :=
definst := $(PATH_BIN)
tool_prefix := LD
bld_trg_base_var := TARGET
$(foreach target, $(PROGRAMS) $(PROGRAMS.$(BUILD_TARGET)) $(PROGRAMS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), \
	$(eval $(value def_pass1_link_common)))


#
# SYSMODS (Pass 1)
#
EXT     := SYS
EXTPRE  :=
definst := $(PATH_SYS)
tool_prefix := LD
bld_trg_base_var := TARGET
$(foreach target, $(SYSMODS) $(SYSMODS.$(BUILD_TARGET)) $(SYSMODS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), \
	$(eval $(value def_pass1_link_common)))


#
# INSTALLS (Pass 1)
# 	Note! INSTARGET_* for INSTALLS aren't available until later.
#
define def_pass1_install
bld_type    := $(firstword $($(target)_BLD_TYPE)     $(BUILD_TYPE))
bld_trg     := $(firstword $($(target)_BLD_TRG)      $(BUILD_TARGET))
bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(BUILD_TARGET_ARCH))
bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(BUILD_TARGET_CPU))
# TARGET_*
TARGET_$(target) := $(PATH_TARGET)/$(target).ins
# INSTARGET_ later.
endef
$(foreach target, $(INSTALLS) $(INSTALLS.$(BUILD_TARGET)) $(INSTALLS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), \
	$(eval $(value def_pass1_install)))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done pass 1)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif




#
#
# Target lists - Pass 2
#
#


## @page pg_fetches 	Fetching Tools, Sources and Similar.
#
# The targets listed in the the FETCHES target list have the following attributes:
#	SOURCES
#	INST
#   FETCHTOOL
#   FETCHFLAGS
#   FETCHDIR
#   UNPACKTOOL
#   UNPACKFLAGS
#
# As usual the target name is an alias for 'creating' the target. Other
# aliases are:
#	pass_fetches
#	fetch
#	unfetch
# 	download
# 	unpack
#
# @remark
#
#   This is a little bit complex because we must guarantee that if a source file
#   changes only sligtly we must refetch it and to a proper unpacking of it. It
#   is also a desire that fetched archives and unpacked files can be deleted to
#   save space.
#
#   Thus, we must be able to cleanup what we've unpacked should any of the
#   sources be removed. We do this by maintaining a file listing the files
#   and directories that was unpacked. This operation is named 'unfetch'.
#
#   We make use of the SIZE and MD5 attributes for each of the sources to
#   create a digest that is stored in the primary target file. Subsequent
#   runswill compare their digest with it to decide if a refetch is required.
#   When a refetch is found necessary, an 'unfetch' is performed first to
#	clean out old files and directores. Note even changes in source order
#   will cause a refetch due to the way the digest is constructed and
#   evaluated.
#
#   By not depending directly on the archives (nor on any unpacked files)
#	but on a goal made up from the archive name, size and md5, we allow
#   the user to delete the archives. Naturally, this means we'll have to
#   check and fetch missing archives before attempting to unpack them.
#
# @remark
#
#	This feature will *NOT* work correctly with vanilla GNU make becuase
#   it makes use of includedep to avoid too many unnecessary files.
#
# @todo
#   1. Download corruption / continuation.
#   2. It's quite possible that there is one too many indirect dependency now...
#

## generates the fetch rule
define def_fetch_src_fetch_rule
# Indirect goal for downloading something.
.PRECIOUS: $(out)
$(out) + $($(target)_$(srcname)_FETCH_OUTPUT_) +| $($(target)_$(srcname)_FETCH_OUTPUT_MAYBE_)  : \
		| $($(target)_$(srcname)_FETCH_DEPORD_)
	$$(call MSG_FETCH_DL,$(target),$(source),$(out))
	@## @todo do fancy stuff like download continuation.
	$$(QUIET)$$(RM) -f $(out)
	$($(target)_$(srcname)_FETCH_CMDS_)
	$$(QUIET)$(if $(md5),$$(MD5SUM_EXT) -b -C $(md5) $(out))



# Intermediate goal for making sure the md5 and size matches. it will (re) fetch the archive if necessary.
$(out).checked_$(md5)_$(size): $($(target)_$(srcname)_FETCH_DEPEND_) | $($(target)_$(srcname)_FETCH_DEPORD_)
	$$(call MSG_FETCH_CHK,$(target),$(source),$(out))
	$$(QUIET)$$(RM) -f $$@
	@# (re)fetch the file if it doesn't exist or if it doesn't matches the md5.
	@## @todo do fancy stuff like download continuation.
	$$(QUIET)( test -f $(out) && $(if $(md5),$$(MD5SUM_EXT) -b -C $(md5) $(out), true) ) \
	          || (   $$(RM_EXT) -f $(out) \
		      && $$(MAKE)      $(out) -f $(MAKEFILE) --no-print-directory )
	$$(QUIET2)$$(APPEND) $$@

_TARGET_$(target)_FETCHED += $(out) $(out).checked_$(md5)_$(size)

# Just a little precaution.
.NOTPARALLEL: $(out) $(out).checked_$(md5)_$(size)

endef

## generates the unpack rule
define def_fetch_src_unpack_rule
# This is the unpack rule. it has an order-only dependency on the download check.
$(out) + $($(target)_$(srcname)_UNPACK_OUTPUT_) +| $($(target)_$(srcname)_UNPACK_OUTPUT_MAYBE_) : \
		$($(target)_$(srcname)_UNPACK_DEPEND_) \
		| $($(target)_$(srcname)_UNPACK_DEPORD_) $(archive).checked_$(md5)_$(size)
	$$(call MSG_FETCH_UP,$(target),$(archive),$(inst))
	$$(QUIET)$$(RM) -f $(out)
	@# if the source archive doesn't exist fetch it (can have been deleted to save space).
	$$(QUIET)test -f $(archive) \
	         || (   $$(RM_EXT) -f $(archive).checked_$(md5)_$(size) \
	             && $$(MAKE)      $(archive).checked_$(md5)_$(size) -f $(MAKEFILE) --no-print-directory )
	$($(target)_$(srcname)_UNPACK_CMDS_)
	$$(QUIET2)$$(APPEND) $(out) $(notdir $(archive).checked_$(md5)_$(size))
	$$(QUIET2)$$(APPEND) $(out) $(notdir $(out))

$(eval _TARGET_$(target)_UNPACKED += $(out))
_TARGET_$(target)_DIGEST := $(_TARGET_$(target)_DIGEST)-$(srcname)_$(md5)_$(size)

.NOTPARALLEL: $(out)

endef

## Processes a fetch source
#
define def_fetch_src
#$ (warning dbg: def_fetch_src: source='$(source)' target='$(target)')

# common
srcname := $(notdir $(source))
inst := $(firstword \
	$($(target)_$(source)_INST)\
	$($(target)_$(srcname)_INST)\
	$($(source)_INST)\
	$($(srcname)_INST)\
	$($(target)_INST)\
)
ifneq ($(patsubst %/,ok,$(inst)),ok)
$(error kBuild: Bad or missing INST property for source '$(source)' in target '$(target)': $(inst))
endif
INSTARGET_$(target)_$(srcname) := $(inst)
fetchdir := $(firstword \
	$($(target)_$(source)_FETCHDIR)\
	$($(target)_$(srcname)_FETCHDIR)\
	$($(source)_FETCHDIR)\
	$($(srcname)_FETCHDIR)\
	$($(target)_FETCHDIR)\
	$(FETCHDIR)\
	$(PATH_TARGET)\
)
deps := \
	$($(target)_$(source)_DEPS)\
	$($(target)_$(srcname)_DEPS)\
	$($(source)_DEPS)\
	$($(srcname)_DEPS)\
	$($(target)_DEPS)
orderdeps := \
	$($(target)_$(source)_ORDERDEPS)\
	$($(target)_$(srcname)_ORDERDEPS)\
	$($(source)_ORDERDEPS)\
	$($(srcname)_ORDERDEPS)\
	$($(target)_ORDERDEPS)
md5 := $(firstword \
	$($(target)_$(source)_MD5)\
	$($(target)_$(srcname)_MD5)\
	$($(source)_MD5)\
	$($(srcname)_MD5)\
	$($(target)_MD5)\
)
size := $(firstword \
	$($(target)_$(source)_SIZE)\
	$($(target)_$(srcname)_SIZE)\
	$($(source)_SIZE)\
	$($(srcname)_SIZE)\
	$($(target)_SIZE)\
)
dep := # not legal for fetch and unpack tools


#
# The fetching.
#
out := $(fetchdir)/$(srcname)
archive := $(out)
TARGET_$(target)_$(srcname) := $(out)
dirdep := $(call DIRDEP,$(fetchdir))
tool := $(firstword \
	$($(target)_$(source)_FETCHTOOL)\
	$($(target)_$(srcname)_FETCHTOOL)\
	$($(target)_$(source)_TOOL)\
	$($(target)_$(srcname)_TOOL)\
	$($(source)_FETCHTOOL)\
	$($(srcname)_FETCHTOOL)\
	$($(source)_TOOL)\
	$($(srcname)_TOOL)\
	$($(target)_FETCHTOOL)\
	$($(target)_TOOL)\
	)
flags :=\
	$(TOOL_$(tool)_FETCHFLAGS)\
	$(FETCHFLAGS)\
	$($(target)_FETCHFLAGS)\
	$($(srcname)_FETCHFLAGS)\
	$($(source)_FETCHFLAGS)\
	$($(target)_$(srcname)_FETCHFLAGS)\
	$($(target)_$(source)_FETCHFLAGS)

#$ (warning dbg: target=$(target) source=$(source) $(srcname)=$(srcname) tool=$(tool) out=$(out) flags=$(flags) dirdep=$(dirdep) fetchdir=$(fetchdir) md5=$(md5) size=$(size))

ifndef TOOL_$(tool)_FETCH_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)_FETCHTOOL)\
	2 $($(target)_$(srcname)_FETCHTOOL)\
	3 $($(target)_$(source)_TOOL)\
	4 $($(target)_$(srcname)_TOOL)\
	5 $($(source)_FETCHTOOL)\
	6 $($(srcname)_FETCHTOOL)\
	7 $($(source)_TOOL)\
	8 $($(srcname)_TOOL)\
	9 $($(target)_FETCHTOOL)\
	10 $($(target)_TOOL) )
$(error kBuild: TOOL_$(tool)_FETCH_CMDS is not defined. source=$(source) target=$(target) )
endif

# call the tool
$(target)_$(srcname)_FETCH_CMDS_   := $(TOOL_$(tool)_FETCH_CMDS)
$(target)_$(srcname)_FETCH_OUTPUT_ := $(TOOL_$(tool)_FETCH_OUTPUT)
$(target)_$(srcname)_FETCH_OUTPUT_MAYBE_ := $(TOOL_$(tool)_FETCH_OUTPUT_MAYBE)
$(target)_$(srcname)_FETCH_DEPEND_ := $(TOOL_$(tool)_FETCH_DEPEND) $(deps)
$(target)_$(srcname)_FETCH_DEPORD_ := $(TOOL_$(tool)_FETCH_DEPORD) $(dirdep) $(orderdeps)

# generate the fetch rule.
$(eval $(def_fetch_src_fetch_rule))


#
# The unpacking / installing.
#
out := $(inst)_kBuild_$(target)_$(srcname)_unpacked.lst
dirdep := $(call DIRDEP,$(inst))
tool := $(firstword \
	$($(target)_$(source)_UNPACKTOOL)\
	$($(target)_$(srcname)_UNPACKTOOL)\
	$($(target)_$(source)_TOOL)\
	$($(target)_$(srcname)_TOOL)\
	$($(source)_UNPACKTOOL)\
	$($(srcname)_UNPACKTOOL)\
	$($(source)_TOOL)\
	$($(srcname)_TOOL)\
	$($(target)_UNPACKTOOL)\
	$($(target)_TOOL) \
	)
ifeq ($(tool),)
tool := $(toupper $(subst .,,$(suffix $(subst tar.,TAR,$(srcname)))))
$(eval $(value def_tools_include))
endif
flags :=\
	$(TOOL_$(tool)_UNPACKFLAGS)\
	$(UNPACKFLAGS)\
	$($(target)_UNPACKFLAGS)\
	$($(srcname)_UNPACKFLAGS)\
	$($(source)_UNPACKFLAGS)\
	$($(target)_$(srcname)_UNPACKFLAGS)\
	$($(target)_$(source)_UNPACKFLAGS)

#$ (warning dbg: target=$(target) source=$(source) $(srcname)=$(srcname) tool=$(tool) out=$(out) flags=$(flags) dirdep=$(dirdep) inst=$(inst) md5=$(md5) size=$(size))
ifndef TOOL_$(tool)_UNPACK_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)_UNPACKTOOL)\
	2 $($(target)_$(srcname)_UNPACKTOOL)\
	3 $($(target)_$(source)_TOOL)\
	4 $($(target)_$(srcname)_TOOL)\
	5 $($(source)_UNPACKTOOL)\
	6 $($(srcname)_UNPACKTOOL)\
	7 $($(source)_TOOL)\
	8 $($(srcname)_TOOL)\
	9 $($(target)_UNPACKTOOL)\
	10 $($(target)_TOOL) \
	11 $(toupper $(subst tar.,TAR,$(ext $(srcname)))) \
	)
$(error kBuild: TOOL_$(tool)_UNPACK_CMDS is not defined. source=$(source) target=$(target) )
endif

# call the tool
$(target)_$(srcname)_UNPACK_CMDS_   := $(TOOL_$(tool)_UNPACK_CMDS)
$(target)_$(srcname)_UNPACK_OUTPUT_ := $(TOOL_$(tool)_UNPACK_OUTPUT)
$(target)_$(srcname)_UNPACK_OUTPUT_MAYBE_ := $(TOOL_$(tool)_UNPACK_OUTPUT_MAYBE)
$(target)_$(srcname)_UNPACK_DEPEND_ := $(TOOL_$(tool)_UNPACK_DEPEND) $(deps)
$(target)_$(srcname)_UNPACK_DEPORD_ := $(TOOL_$(tool)_UNPACK_DEPORD) $(dirdep) $(orderdeps)

# generate the fetch rule.
$(eval $(def_fetch_src_unpack_rule))

_DIRS += $(inst) $(fetchdir)

endef


##
# Define the target level rules for a fetch.
# @param	target
# @param	out
# @param	inst
# @param	_TARGET_$(target)_UNPACKED
# @param	_TARGET_$(target)_DIGEST
# @param	bld_trg
# @param	bld_trg_arch
define def_fetch_rules

$(out).lst: $(_TARGET_$(target)_UNPACKED) | $(call DIRDEP,$(inst))
	$$(call MSG_FETCH_OK,$(target))
	$$(QUIET)$$(RM) -f $$@ $$@.tmp
	$$(QUIET2)$$(APPEND) $$@.tmp '$(notdir $(out))'
	$$(QUIET)$(if $(_TARGET_$(target)_UNPACKED),$$(CAT_EXT) $(_TARGET_$(target)_UNPACKED) >> $$@.tmp)
	$$(QUIET)$$(MV) -f $$@.tmp $$@

$(out)_unfetched:
	$$(call MSG_UNFETCH,$(target))
	$$(QUIET)$$(RM) -f $$(addprefix $(inst),$$(shell $$(CAT_EXT) $(out).lst 2> /dev/null | $$(SED) -e '/\/$$$$/d'))
	$$(QUIET)$$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist $$(dir $$@) \
		$$(addprefix $(inst),$$(sort $$(dir $$(shell $$(CAT_EXT) $(out).lst 2> /dev/null))))
	$$(QUIET)$$(RM) -f $(out).lst $(out)
	$$(QUIET)$$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist $$(dir $$@)

$(out): $(comp-vars _TARGET_$(target)_DIGEST_PREV,_TARGET_$(target)_DIGEST,FORCE) | $(call DIRDEP,$(inst))
	$$(QUIET)$$(RM) -f $$@
	$$(if $$(_TARGET_$(target)_DIGEST),$$(if $$(wildcard $(out).lst)\
		,$$(call MSG_REFETCH,$(target)),$$(call MSG_FETCH,$(target))),$$(call MSG_UNFETCH,$(target)))
	$$(QUIET)$$(if $$(wildcard $(out).lst      ),$$(MAKE) -f $(MAKEFILE) --no-print-directory $(out)_unfetched)
	$$(QUIET)$$(if  $$(_TARGET_$(target)_DIGEST),$$(MAKE) -f $(MAKEFILE) --no-print-directory $(out).lst,$$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist $$(dir $$@))
	$$(QUIET2)$$(if $$(_TARGET_$(target)_DIGEST),$$(APPEND) $$@ "_TARGET_$(target)_DIGEST_PREV := $(_TARGET_$(target)_DIGEST)")

.NOTPARALLEL: $(out).lst $(out)_unfetched $(out)

endef


##
# Deal with one fetch target.
# @param	target
# @param	bld_trg
# @param	bld_trg_arch
define def_fetch
# common
INSTARGET_$(target) := $($(target)_INST)
ifneq ($(patsubst %/,ok,$(INSTARGET_$(target))),ok)
$(error kBuild: Bad or missing INST property for target '$(target)'. \
	$(target)_INST='$($(target)_INST)' ($(origin $(target)_INST)))
endif
_TARGET_$(target)_FETCHED :=
_TARGET_$(target)_UNPACKED :=
_TARGET_$(target)_DIGEST :=

# The 'sources'.
#$ (warning dbg fetch: target=$(target) sources=$($(target)_SOURCES) $($(target)_SOURCES.$(BUILD_TYPE)) $($(target)_SOURCES.$(BUILD_TARGET)) $($(target)_SOURCES.$(BUILD_TARGET_ARCH)) $($(target)_SOURCES.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)))
$(foreach source,$($(target)_SOURCES) $($(target)_SOURCES.$(BUILD_TYPE)) $($(target)_SOURCES.$(BUILD_TARGET)) $($(target)_SOURCES.$(BUILD_TARGET_ARCH)) $($(target)_SOURCES.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)),\
	$(eval $(value def_fetch_src)))

# The target.
inst := $(INSTARGET_$(target))
out := $(inst)_kBuild_fetch_$(target)

$(eval includedep $(out))

$(eval $(def_fetch_rules))

# Define the aliases here (doesn't work if defined in def_fetch_rules, just like includedep).
$(target): $(out)
$(target)_unfetch: $(out)_unfetched

_FETCHES += $(out)
_DOWNLOADS += $(_TARGET_$(target)_FETCHED)
_UNPACKS += $(_TARGET_$(target)_UNPACKED)
_UNFETCHES += $(out)_unfetched
_DIRS += $(inst)

endef

# Walk the FETCH target lists.
bld_trg := $(BUILD_TARGET)
bld_trg_arch := $(BUILD_TARGET_ARCH)
$(foreach target, $(FETCHES) $(FETCHES.$(BUILD_TARGET)) $(FETCHES.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), \
	$(eval $(value def_fetch)))

# some aliases.
download: $(_DOWNLOADS)
unpack: $(_UNPACKS)
fetch: $(_FETCHES)
unfetch: $(_UNFETCHES)

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done fetching targets)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif



##
## Patching.
##
##
#define def_patch_src
#
#endef
#
#
## Deal with one patch target.
#define def_patch
#
#$(foreach source,$($(target)_SOURCES) $($(target)_SOURCES.$(BUILD_TYPE)) $($(target)_SOURCES.$(BUILD_TARGET)) $($(target)_SOURCES.$(BUILD_TARGET_ARCH)) $($(target)_SOURCES.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)),\
#	$(eval $(value def_patch_src)))
#
#_PATCHES +=
#endef
#
#$(foreach target, $(PATCHES) $(PATCHES.$(BUILD_TARGET)) $(PATCHES.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), \
#	$(eval $(value def_patch)))
#


#
# Object processing.
#

## wrapper the compile command dependency check.
ifndef NO_COMPILE_CMDS_DEPS
 _DEP_COMPILE_CMDS = $(comp-cmds $(target)_$(source)_CMDS_PREV_,$(target)_$(source)_CMDS_,FORCE)
else
 _DEP_COMPILE_CMDS =
endif

## Generates the rules for building a specific object, and the aliases
# for building a source file.
# @param    $(obj)    The object file.
define def_target_source_rule

ifdef TOOL_$(tool)_COMPILE_$(type)_USES_KOBJCACHE
$(outbase).koc +| $(obj) $($(target)_$(source)_OUTPUT_) $($(target)_$(source)_OUTPUT_MAYBE_) : \
		$($(target)_$(source)_DEPEND_) \
		$(_DEP_COMPILE_CMDS) \
		| \
		$($(target)_$(source)_DEPORD_)
	$$(call MSG_COMPILE,$(target),$(source),$$@,$(type))
else
$(obj) + $($(target)_$(source)_OUTPUT_) +| $($(target)_$(source)_OUTPUT_MAYBE_) : \
		$($(target)_$(source)_DEPEND_) \
		$(_DEP_COMPILE_CMDS) \
		| \
		$($(target)_$(source)_DEPORD_)
	$$(call MSG_COMPILE,$(target),$(source),$$@,$(type))
ifdef TOOL_$(tool)_COMPILE_$(type)_DONT_PURGE_OUTPUT
	$$(QUIET)$$(RM) -f $(dep) $(obj) $($(target)_$(source)_OUTPUT_) $($(target)_OUTPUT_MAYBE_)
endif
endif

$($(target)_$(source)_CMDS_)

ifndef NO_COMPILE_CMDS_DEPS
	$$(QUIET2)$$(APPEND) '$(dep)'
	$$(QUIET2)$$(APPEND) '$(dep)' 'define $(target)_$(source)_CMDS_PREV_'
	$$(QUIET2)$$(APPEND) -v '$(dep)' '$(target)_$(source)_CMDS_'
	$$(QUIET2)$$(APPEND) '$(dep)' 'endef'
endif

$(basename $(notdir $(obj))).o: $(obj)
$(basename $(notdir $(obj))).obj: $(obj)
endef


## wrapper the link command dependency check.
ifndef NO_COMPILE_CMDS_DEPS
 _DEP_LINK_CMDS = $(comp-cmds $(target)_CMDS_PREV_,$(target)_CMDS_,FORCE)
else
 _DEP_LINK_CMDS =
endif

## Generate the link rule for a target.
# @param    $(target)               The normalized target name.
# @param    $(dirdep)               Directories we depend upon begin created before linking.
# @param    $(dep)                  The name of the dependency file.
# @param    $(out)
# @param    $($(target)_OUTPUT_)    Output files from the link.
# @param    $($(target)_OUTPUT_MAYBE_)	Output files that the link may perhaps create.
# @param    $($(target)_DEPEND_)	Dependencies.
# @param    $($(target)_DEPORD_)    Dependencies which should only affect build order.
# @param    $($(target)_CMDS_)      The link commands.
# @param    $($(target)_CMDS_PREV_) The link commands from the previous run.
define def_link_rule
$(out) + $($(target)_OUTPUT_) +| $($(target)_OUTPUT_MAYBE_) : \
		$($(target)_DEPEND_) \
		$(_DEP_LINK_CMDS) \
		| \
		$($(target)_DEPORD_)
	$$(call MSG_LINK,$(target),$$@,$(tool_do))
	$$(QUIET)$$(RM) -f $(dep) $(out) $($(target)_OUTPUT_) $($(target)_OUTPUT_MAYBE_)

$($(target)_CMDS_)

ifndef NO_LINK_CMDS_DEPS
	$$(QUIET2)$$(APPEND) '$(dep)' 'define $(target)_CMDS_PREV_'
	$$(QUIET2)$$(APPEND) -v '$(dep)' '$(target)_CMDS_'
	$$(QUIET2)$$(APPEND) '$(dep)' 'endef'
endif

$(basename $(notdir $(out))): $(out)

endef


## Generate the link & lib install rule
# @param    $(target)   Normalized target name.
# @param    $(out)      The build target.
# @param    $(INSTARGET_$(target))  The installation targets.
# @param    $(mode)     The file mode (optional)
define def_link_install_rule
$(INSTARGET_$(target)) : $(out) | $(call DIRDEP,$(dir $(INSTARGET_$(target))))
	$$(call MSG_INST_TRG,$(target),$(out),$$@)
	$$(QUIET)$$(INSTALL) $$(if $(mode),-m $(mode)) $(out) $$@

ifdef KBUILD_DO_AUTO_INSTALL
$(basename $(notdir $(out))): $(INSTARGET_$(target))
endif
endef


## Generic macro for processing C, C++ and Assembly sources.
# @param    $(target)     Normalized target name.
# @param    $(source)     Source file name.
# @param    $(type)       Source type. {C,CXX,AS,OBJC}
# @param    bld_type      Build type.
# @param    bld_trg       Build target.
# @param    bld_trg_arch  Build target arch.
# @param    bld_trg_cpu   Build target cpu.
def_target_source_c_cpp_objc_asm_rc_new = $(kb-src-one )
ifdef KMK_VERSION
 def_target_source_c_cpp_objc_asm_rc_var = def_target_source_c_cpp_objc_asm_rc_new
else
 def_target_source_c_cpp_objc_asm_rc_var = def_target_source_c_cpp_objc_asm_rc_old
endif

## Generic macro for processing all target sources.
# @param    $(target)   Normalized target name.
# @param    $(defpath)
# @param    much-more...
define def_target_sources
#$ (warning def_target_sources)
# C sources
type := C
$(foreach source, $(filter %.c             , $($(target)_SOURCES) $($(target)_SOURCES.$(bld_trg)) $($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_cpu)) $($(target)_SOURCES.$(bld_type)))\
   ,$(eval $(value $(def_target_source_c_cpp_objc_asm_rc_var))) )

# C++ sources
type := CXX
$(foreach source, $(filter %.cpp %.cxx %.xx, $($(target)_SOURCES) $($(target)_SOURCES.$(bld_trg)) $($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_cpu)) $($(target)_SOURCES.$(bld_type)))\
	,$(eval $(value $(def_target_source_c_cpp_objc_asm_rc_var))) )

# Objective-C sources
type := OBJC
$(foreach source, $(filter %.m,              $($(target)_SOURCES) $($(target)_SOURCES.$(bld_trg)) $($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_cpu)) $($(target)_SOURCES.$(bld_type)))\
	,$(eval $(value $(def_target_source_c_cpp_objc_asm_rc_var))) )

# ASM sources
type := AS
$(foreach source, $(filter %.asm %.s %.S   , $($(target)_SOURCES) $($(target)_SOURCES.$(bld_trg)) $($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_cpu)) $($(target)_SOURCES.$(bld_type)))\
	,$(eval $(value $(def_target_source_c_cpp_objc_asm_rc_var))) )

# Resource sources
type := RC
$(foreach source, $(filter %.rc            , $($(target)_SOURCES) $($(target)_SOURCES.$(bld_trg)) $($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_cpu)) $($(target)_SOURCES.$(bld_type)))\
	,$(eval $(value $(def_target_source_c_cpp_objc_asm_rc_var))) )

endef



## Generic macro for generating the install rule(s) for a target
# and update the globals with default out.
#
# @param	$(target)   Normalized target name.
# @param	$(out)      The output file.
# @param	$(definst)  The default _INST value.
# @param	$(typevar)  The name of the variable with all the root targets of its type.
# @remark   Only library uses this now.
define def_target_install_pluss
ifndef $(target)_NOINST
INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)), \
	$(if $($(target)_INST), $(addprefix $(PATH_INS)/,$($(target)_INST)), $(definst)/))

$(eval $(def_link_install_rule))

_INSTALLS_FILES += $(INSTARGET_$(target))

ifdef KBUILD_DO_AUTO_INSTALL
$(typevar) += $(INSTARGET_$(target))
else
$(typevar) += $(out)
endif
else # _NOINST
$(typevar) += $(out)
endif

_OUT_FILES += $($(target)_OUTPUT_) $($(target)_OUTPUT_MAYBE_) $(out)
_CLEAN_FILES += $($(target)_CLEAN) $($(target)_CLEAN.$(bld_trg)) $($(target)_CLEAN.$(bld_trg).$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_cpu)) $($(target)_CLEAN.$(bld_type))
_DIRS += $($(target)_BLDDIRS) $($(target)_BLDDIRS.$(bld_trg)) $($(target)_BLDDIRS.$(bld_trg).$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_cpu)) $($(target)_BLDDIRS.$(bld_type))
_OBJS += $($(target)_OBJS_)

endef



#
# LIBRARIES
#

## Library (one).
# @param    $(target)   Normalized library (target) name.
define def_lib
# library basics
## @todo prefix
bld_type    := $(firstword $($(target)_BLD_TYPE)     $(BUILD_TYPE))
bld_trg     := $(firstword $($(target)_BLD_TRG)      $(BUILD_TARGET))
bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(BUILD_TARGET_ARCH))
bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(BUILD_TARGET_CPU))
tool        := $(call _TARGET_TOOL,$(target),AR)
ifeq ($(tool),)
$(error kBuild: Library target $(target) does not have a tool defined!)
endif
name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
outbase     := $(call TARGET_BASE,$(name),$(target))
ifndef PATH_$(target)
 PATH_$(target) := $(patsubst %/,%,$(dir $(outbase)))
else
 ifneq ($(PATH_$(target)),$(patsubst %/,%,$(dir $(outbase))))
  $(error kBuild internal error: PATH_$(target)=$(PATH_$(target)) expected $(patsubst %/,%,$(dir $(outbase))))
 endif
endif
suff        := $(firstword\
	$($(target)_LIBSUFF.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LIBSUFF.$(bld_trg))\
	$($(target)_LIBSUFF)\
	$(TOOL_$(tool)_ARLIBSUFF.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_ARLIBSUFF.$(bld_trg))\
	$(TOOL_$(tool)_ARLIBSUFF)\
	$(SUFF_LIB))
out         := $(outbase)$(suff)
TARGET_$(target) := $(out)
$(target)_OBJS_ :=
defpath := $($(target)_PATH)

# source -> object
$(eval $(value def_target_sources))

# library linking
tool        := $(call _TARGET_TOOL,$(target),AR)
name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
outbase     := $(call TARGET_BASE,$(name),$(target))
flags       :=\
	$(TOOL_$(tool)_ARFLAGS)\
	$(TOOL_$(tool)_ARFLAGS.$(bld_type))\
	$(ARFLAGS)\
	$(ARFLAGS.$(bld_type))\
	$($(target)_ARFLAGS)\
	$($(target)_ARFLAGS.$(bld_type)) \
	$($(target)_ARFLAGS.$(bld_trg)) \
	$($(target)_ARFLAGS.$(bld_trg_arch)) \
	$($(target)_ARFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_ARFLAGS.$(bld_trg_cpu))
othersrc    := $(filter-out %.c %.cpp %.cxx %.cc %.m %.s %.S %.asm %.rc %.o %.obj %.res,\
	$($(target)_SOURCES) \
	$($(target)_SOURCES.$(bld_trg)) \
	$($(target)_SOURCES.$(bld_trg_arch)) \
	$($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_SOURCES.$(bld_trg_cpu)) \
	$($(target)_SOURCES.$(bld_type)))
objs         = $(filter %.o %.obj %.res, \
	$($(target)_SOURCES) \
	$($(target)_SOURCES.$(bld_trg)) \
	$($(target)_SOURCES.$(bld_trg_arch)) \
	$($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_SOURCES.$(bld_trg_cpu)) \
	$($(target)_SOURCES.$(bld_type))) \
    $($(target)_OBJS_)
dirdep      := $(call DIRDEP,$(dir $(out)))
deps        := $($(target)_DEPS)
orderdeps   := $($(target)_ORDERDEPS)

# Adjust paths if we got a default path.
ifneq ($(defpath),)
 objs := $(abspathex $(objs),$(defpath))
 deps := $(abspathex $(deps),$(defpath))
 orderdeps := $(abspathex $(orderdeps),$(defpath))
 othersrc := $(abspathex $(othersrc),$(defpath))
endif


# Custom pre-link actions.
ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_type)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_type))
else ifdef $(target)_PRE_CMDS.$(bld_trg_arch)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_trg_arch))
else ifdef $(target)_PRE_CMDS.$(bld_trg)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_trg))
else ifdef $(target)_PRE_CMDS.$(bld_type)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_type))
else ifdef $(target)_PRE_CMDS
 pre_cmds := $($(target)_PRE_CMDS)
else ifdef PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef PRE_CMDS.$(bld_trg).$(bld_trg_arch)
 pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef PRE_CMDS.$(bld_trg).$(bld_type)
 pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_type))
else ifdef PRE_CMDS.$(bld_trg_arch)
 pre_cmds := $(PRE_CMDS.$(bld_trg_arch))
else ifdef PRE_CMDS.$(bld_trg)
 pre_cmds := $(PRE_CMDS.$(bld_trg))
else ifdef PRE_CMDS.$(bld_type)
 pre_cmds := $(PRE_CMDS.$(bld_type))
else
 pre_cmds := $(PRE_CMDS)
endif

# Custom post-link actions.
ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch)
 post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_type)
 post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_type))
else ifdef $(target)_POST_CMDS.$(bld_trg_arch)
 post_cmds := $($(target)_POST_CMDS.$(bld_trg_arch))
else ifdef $(target)_POST_CMDS.$(bld_trg)
 post_cmds := $($(target)_POST_CMDS.$(bld_trg))
else ifdef $(target)_POST_CMDS.$(bld_type)
 post_cmds := $($(target)_POST_CMDS.$(bld_type))
else ifdef $(target)_POST_CMDS
 post_cmds := $($(target)_POST_CMDS)
else ifdef POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 post_cmds := $(POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef POST_CMDS.$(bld_trg).$(bld_trg_arch)
 post_cmds := $(POST_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef POST_CMDS.$(bld_trg).$(bld_type)
 post_cmds := $(POST_CMDS.$(bld_trg).$(bld_type))
else ifdef POST_CMDS.$(bld_trg_arch)
 post_cmds := $(POST_CMDS.$(bld_trg_arch))
else ifdef POST_CMDS.$(bld_trg)
 post_cmds := $(POST_CMDS.$(bld_trg))
else ifdef POST_CMDS.$(bld_type)
 post_cmds := $(POST_CMDS.$(bld_type))
else
 post_cmds := $(POST_CMDS)
endif

# dependency file
dep := $(out)$(SUFF_DEP)
ifndef NO_LINK_CMDS_DEPS
 _DEPFILES_INCLUDED += $(dep)
 $(eval includedep $(dep))
endif

# check that the tool is defined.
ifndef TOOL_$(tool)_LINK_LIBRARY_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	2 $($(target)_$(source)TOOL.$(bld_trg)) \
	3 $($(target)_$(source)TOOL) \
	4 $($(target)_TOOL.$(bld_trg).$(bld_trg_arch)) \
	5 $($(target)_TOOL.$(bld_trg)) \
	6 $($(target)_TOOL) \
	7 $($(source)TOOL) \
	8 $($(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	9 $($(source)TOOL.$(bld_trg)) \
	10 $(TOOL.$(bld_trg).$(bld_trg_arch)) \
	11 $(TOOL.$(bld_trg)) \
	12 $(TOOL) )
$(error kBuild: TOOL_$(tool)_LINK_LIBRARY_CMDS isn't defined! target=$(target) )
endif

# call the tool
$(target)_CMDS_   := $(TOOL_$(tool)_LINK_LIBRARY_CMDS)
ifneq ($(pre_cmds),)
 $(target)_CMDS_  := $(TAB)$(pre_cmds)$(NL)$(TAB)$($(target)_CMDS_)
endif
ifneq ($(post_cmds),)
 $(target)_CMDS_  := $($(target)_CMDS_)$(NL)$(TAB)$(post_cmds)
endif
$(target)_OUTPUT_ := $(TOOL_$(tool)_LINK_LIBRARY_OUTPUT)
$(target)_OUTPUT_MAYBE_ := $(TOOL_$(tool)_LINK_LIBRARY_OUTPUT_MAYBE)
$(target)_DEPEND_ := $(TOOL_$(tool)_LINK_LIBRARY_DEPEND) $(deps) $(objs)
$(target)_DEPORD_ := $(TOOL_$(tool)_LINK_LIBRARY_DEPORD) $(dirdep) $(orderdeps)

# generate the link rule.
$(eval $(def_link_rule))

# installing and globals
$(eval $(value def_target_install_pluss))
endef

# Process libraries
definst := $(PATH_LIB)
typevar := _LIBS
tool_do := LINK_LIBRARY
mode := 0644
$(foreach target, $(LIBRARIES) $(LIBRARIES.$(BUILD_TARGET)) $(LIBRARIES.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), $(eval $(value def_lib)))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done library targets)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# Link operations.
#

##
# Link prolog
#
# @param    $(target)   Normalized target name.
# @param    $(EXT)      EXE,DLL,SYS.
# @param    $(definst)  The default _INST value.
# @param    $(typevar)  The name of the variable with all the root targets of its type.
define def_link_common
# basics
bld_type    := $(firstword $($(target)_BLD_TYPE)     $(BUILD_TYPE))
bld_trg     := $(firstword $($(target)_BLD_TRG)      $(BUILD_$(bld_trg_base_var)))
bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(BUILD_$(bld_trg_base_var)_ARCH))
bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(BUILD_$(bld_trg_base_var)_CPU))

tool        := $(call _TARGET_TOOL,$(target),LD)
name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
outbase     := $(call TARGET_BASE,$(name),$(target))
ifndef PATH_$(target)
 PATH_$(target) := $(patsubst %/,%,$(dir $(outbase)))
else
 ifneq ($(PATH_$(target)),$(patsubst %/,%,$(dir $(outbase))))
  $(error kBuild internal error: PATH_$(target)=$(PATH_$(target)) expected $(patsubst %/,%,$(dir $(outbase))))
 endif
endif
suff        := $(firstword \
	$($(target)_$(EXT)SUFF) \
	$($(target)_$(EXT)SUFF) \
	$(TOOL_$(tool)_LD$(EXT)SUFF) \
	$($(EXTPRE)SUFF_$(EXT)))
out         := $(outbase)$(suff)
TARGET_$(target) := $(out)
$(target)_OBJS_  :=
defpath := $($(target)_PATH)

# source -> object
$(eval $(value def_target_sources))

# more link stuff.
tool        := $(call _TARGET_TOOL,$(target),LD)
name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
outbase     := $(call TARGET_BASE,$(name),$(target))
flags       :=\
	$(TOOL_$(tool)_LDFLAGS)\
	$(TOOL_$(tool)_LDFLAGS.$(bld_type))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg_arch))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg_cpu))\
	$(foreach sdk, $(SDKS) \
	               $(SDKS.$(bld_type)) \
	               $(SDKS.$(bld_trg)) \
	               $(SDKS.$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg).$(bld_trg_arch)),\
		$(SDK_$(sdk)_LDFLAGS)\
		$(SDK_$(sdk)_LDFLAGS.$(bld_type))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_cpu)))\
	$(LDFLAGS)\
	$(LDFLAGS.$(bld_type))\
	$(LDFLAGS.$(bld_trg))\
	$(LDFLAGS.$(bld_trg_arch))\
	$(LDFLAGS.$(bld_trg).$(bld_trg_arch))\
	$(LDFLAGS.$(bld_trg_cpu))\
	$(foreach sdk, $($(target)_SDKS) \
	               $($(target)_SDKS.$(bld_type)) \
	               $($(target)_SDKS.$(bld_trg)) \
	               $($(target)_SDKS.$(bld_trg_arch)) \
	               $($(target)_SDKS.$(bld_trg).$(bld_trg_arch)),\
		$(SDK_$(sdk)_LDFLAGS)\
		$(SDK_$(sdk)_LDFLAGS.$(bld_type))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_cpu)))\
	$($(target)_LDFLAGS)\
	$($(target)_LDFLAGS.$(bld_type))\
	$($(target)_LDFLAGS.$(bld_trg))\
	$($(target)_LDFLAGS.$(bld_trg_arch))\
	$($(target)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LDFLAGS.$(bld_trg_cpu))
othersrc    := $(filter-out %.c %.cpp %.cxx %.cc %.m %.s %.S %.asm %.rc %.o %.obj %.res,\
	$($(target)_SOURCES)\
	$($(target)_SOURCES.$(bld_trg)) \
	$($(target)_SOURCES.$(bld_trg_arch)) \
	$($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_SOURCES.$(bld_trg_cpu)) \
	$($(target)_SOURCES.$(bld_type)))
objs         = $(filter %.o %.obj %.res, \
	$($(target)_SOURCES) \
	$($(target)_SOURCES.$(bld_trg)) \
	$($(target)_SOURCES.$(bld_trg_arch)) \
	$($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_SOURCES.$(bld_trg_cpu)) \
	$($(target)_SOURCES.$(bld_type))) \
	$($(target)_OBJS_)
libs        :=\
	$($(target)_LIBS.$(bld_trg_cpu))\
	$($(target)_LIBS.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LIBS.$(bld_trg_arch))\
	$($(target)_LIBS.$(bld_trg))\
	$($(target)_LIBS.$(bld_type))\
	$($(target)_LIBS)\
	$(foreach sdk, $($(target)_SDKS.$(bld_trg).$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg)) \
		       $($(target)_SDKS.$(bld_type)) \
		       $($(target)_SDKS),\
		$(SDK_$(sdk)_LIBS.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg))\
		$(SDK_$(sdk)_LIBS.$(bld_type))\
		$(SDK_$(sdk)_LIBS))\
	$(LIBS.$(bld_trg_cpu))\
	$(LIBS.$(bld_trg).$(bld_trg_arch))\
	$(LIBS.$(bld_trg_arch))\
	$(LIBS.$(bld_trg))\
	$(LIBS.$(bld_type))\
	$(LIBS)\
	$(foreach sdk, $(SDKS.$(bld_trg).$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg)) \
	               $(SDKS.$(bld_type)) \
	               $(SDKS),\
		$(SDK_$(sdk)_LIBS.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg))\
		$(SDK_$(sdk)_LIBS.$(bld_type))\
		$(SDK_$(sdk)_LIBS))\
	$(TOOL_$(tool)_LIBS.$(bld_trg_cpu))\
	$(TOOL_$(tool)_LIBS.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBS.$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBS.$(bld_trg))\
	$(TOOL_$(tool)_LIBS.$(bld_type))\
	$(TOOL_$(tool)_LIBS)
libpath    :=\
	$($(target)_LIBPATH.$(bld_trg_cpu))\
	$($(target)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LIBPATH.$(bld_trg_arch))\
	$($(target)_LIBPATH.$(bld_trg))\
	$($(target)_LIBPATH.$(bld_type))\
	$($(target)_LIBPATH)\
	$(foreach sdk, $($(target)_SDKS.$(bld_trg).$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg)) \
		       $($(target)_SDKS.$(bld_type)) \
		       $($(target)_SDKS),\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg))\
		$(SDK_$(sdk)_LIBPATH.$(bld_type))\
		$(SDK_$(sdk)_LIBPATH))\
	$(LIBPATH.$(bld_trg_cpu))\
	$(LIBPATH.$(bld_trg).$(bld_trg_arch))\
	$(LIBPATH.$(bld_trg_arch))\
	$(LIBPATH.$(bld_trg))\
	$(LIBPATH.$(bld_type))\
	$(LIBPATH)\
	$(foreach sdk, $(SDKS.$(bld_trg).$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg)) \
	               $(SDKS.$(bld_type)) \
	               $(SDKS),\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg))\
		$(SDK_$(sdk)_LIBPATH.$(bld_type))\
		$(SDK_$(sdk)_LIBPATH))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg_cpu))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg))\
	$(TOOL_$(tool)_LIBPATH.$(bld_type))\
	$(TOOL_$(tool)_LIBPATH)
dirdep      := $(call DIRDEP,$(dir $(out)))
deps        := $($(target)_DEPS)
orderdeps   := $($(target)_ORDERDEPS)

# Adjust paths if we got a default path.
ifneq ($(defpath),)
 libpath := $(abspathex $(libpath),$(defpath))
 objs := $(abspathex $(objs),$(defpath))
 deps := $(abspathex $(deps),$(defpath))
 orderdeps := $(abspathex $(orderdeps),$(defpath))
 othersrc := $(abspathex $(othersrc),$(defpath))
 # libs are not subject to this because of the the -l<lib> stuff. Use $(<target>_PATH)/lib if relative to current dir!
endif

# Custom pre-link actions.
ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_type)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_type))
else ifdef $(target)_PRE_CMDS.$(bld_trg_arch)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_trg_arch))
else ifdef $(target)_PRE_CMDS.$(bld_trg)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_trg))
else ifdef $(target)_PRE_CMDS.$(bld_type)
 pre_cmds := $($(target)_PRE_CMDS.$(bld_type))
else ifdef $(target)_PRE_CMDS
 pre_cmds := $($(target)_PRE_CMDS)
else ifdef PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef PRE_CMDS.$(bld_trg).$(bld_trg_arch)
 pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef PRE_CMDS.$(bld_trg).$(bld_type)
 pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_type))
else ifdef PRE_CMDS.$(bld_trg_arch)
 pre_cmds := $(PRE_CMDS.$(bld_trg_arch))
else ifdef PRE_CMDS.$(bld_trg)
 pre_cmds := $(PRE_CMDS.$(bld_trg))
else ifdef PRE_CMDS.$(bld_type)
 pre_cmds := $(PRE_CMDS.$(bld_type))
else
 pre_cmds := $(PRE_CMDS)
endif

# Custom post-link actions.
ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch)
 post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_type)
 post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_type))
else ifdef $(target)_POST_CMDS.$(bld_trg_arch)
 post_cmds := $($(target)_POST_CMDS.$(bld_trg_arch))
else ifdef $(target)_POST_CMDS.$(bld_trg)
 post_cmds := $($(target)_POST_CMDS.$(bld_trg))
else ifdef $(target)_POST_CMDS.$(bld_type)
 post_cmds := $($(target)_POST_CMDS.$(bld_type))
else ifdef $(target)_POST_CMDS
 post_cmds := $($(target)_POST_CMDS)
else ifdef POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 post_cmds := $(POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef POST_CMDS.$(bld_trg).$(bld_trg_arch)
 post_cmds := $(POST_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef POST_CMDS.$(bld_trg).$(bld_type)
 post_cmds := $(POST_CMDS.$(bld_trg).$(bld_type))
else ifdef POST_CMDS.$(bld_trg_arch)
 post_cmds := $(POST_CMDS.$(bld_trg_arch))
else ifdef POST_CMDS.$(bld_trg)
 post_cmds := $(POST_CMDS.$(bld_trg))
else ifdef POST_CMDS.$(bld_type)
 post_cmds := $(POST_CMDS.$(bld_type))
else
 post_cmds := $(POST_CMDS)
endif

# installation targets
ifndef $(target)_NOINST
INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)), \
	$(if $($(target)_INST), $(addprefix $(PATH_INS)/,$($(target)_INST)), $(definst)/))
ifdef KBUILD_DO_AUTO_INSTALL
$(typevar)  += $(INSTARGET_$(target))
else
$(typevar)  += $(out)
endif
# generate the install rule
$(eval $(def_link_install_rule))

else # NOINST
INSTARGET_$(target) :=
$(typevar)  += $(out)
endif # NOINST

# dependency file
dep := $(outbase)$(SUFF_DEP)
ifndef NO_LINK_CMDS_DEPS
 _DEPFILES_INCLUDED += $(dep)
 $(eval includedep $(dep))
endif

# check that the tool is defined.
ifndef TOOL_$(tool)_$(tool_do)_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	2 $($(target)_$(source)TOOL.$(bld_trg)) \
	3 $($(target)_$(source)TOOL) \
	4 $($(target)_TOOL.$(bld_trg).$(bld_trg_arch)) \
	5 $($(target)_TOOL.$(bld_trg)) \
	6 $($(target)_TOOL) \
	7 $($(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	8 $($(source)TOOL.$(bld_trg)) \
	9 $($(source)TOOL) \
	10 $(TOOL.$(bld_trg).$(bld_trg_arch)) \
	11 $(TOOL.$(bld_trg)) \
	12 $(TOOL) )
$(error kBuild: TOOL_$(tool)_$(tool_do)_CMDS isn't defined! target=$(target) )
endif

# call the tool
$(target)_CMDS_   := $(TOOL_$(tool)_$(tool_do)_CMDS)
ifneq ($(pre_cmds),)
 $(target)_CMDS_  := $(TAB)$(pre_cmds)$(NL)$(TAB)$($(target)_CMDS_)
endif
ifneq ($(post_cmds),)
 $(target)_CMDS_  := $($(target)_CMDS_)$(NL)$(TAB)$(post_cmds)
endif
$(target)_OUTPUT_ := $(TOOL_$(tool)_$(tool_do)_OUTPUT)
$(target)_OUTPUT_MAYBE_ := $(TOOL_$(tool)_$(tool_do)_OUTPUT_MAYBE)
$(target)_DEPEND_ := $(TOOL_$(tool)_$(tool_do)_DEPEND) $(deps) $(objs)
$(target)_DEPORD_ := $(TOOL_$(tool)_$(tool_do)_DEPORD) $(dirdep) $(orderdeps)

# generate the link rule.
$(eval $(def_link_rule))


# Update globals.
_OBJS += $($(target)_OBJS_)
_OUT_FILES += $($(target)_OUTPUT_) $(out)
_CLEAN_FILES += $($(target)_CLEAN) $($(target)_CLEAN.$(bld_trg)) $($(target)_CLEAN.$(bld_trg).$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_cpu)) $($(target)_CLEAN.$(bld_type))
_DIRS += $($(target)_BLDDIRS) $($(target)_BLDDIRS.$(bld_trg)) $($(target)_BLDDIRS.$(bld_trg).$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_cpu)) $($(target)_BLDDIRS.$(bld_type))
_INSTALLS_FILES += $(INSTARGET_$(target))

endef


#
# BLDPROGS
#

## Build program (one).
# @param    $(target)   Normalized target (program) name.
define def_bldprog

# set NOINST if not forced installation.
ifndef $(target)_INST
$(target)_NOINST := 1
endif

# do the usual stuff.
$(eval $(value def_link_common))

endef

# Process build programs.
EXT     := EXE
EXTPRE  := HOST
tool_do := LINK_PROGRAM
definst := $(PATH_BIN)
typevar := _BLDPROGS
mode    := 0755
bld_trg_base_var := PLATFORM
$(foreach target, $(BLDPROGS) $(BLDPROGS.$(BUILD_PLATFORM)) $(BLDPROGS.$(BUILD_PLATFORM).$(BUILD_PLATFORM_ARCH)), $(eval $(value def_bldprog)))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done build program targets)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# DLLS
#

# Process dlls
EXT     := DLL
EXTPRE  :=
tool_do := LINK_DLL
definst := $(PATH_DLL)
typevar := _DLLS
mode    := 0644
bld_trg_base_var := TARGET
$(foreach target, $(DLLS) $(DLLS.$(BUILD_TARGET)) $(DLLS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), $(eval $(value def_link_common)))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done dll targets)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# IMPORT LIBRARIES
#
#   - On OS/2 and windows these are libraries.
#   - On other platforms they are fake DLLs.
#
EXTPRE  :=
typevar := _IMPORT_LIBS
mode    := 0644
bld_trg_base_var := TARGET
ifeq ($(filter-out nt os2 win win64 win32,$(BUILD_TARGET)),)
 EXT     := LIB
 tool_do := LINK_LIBRARY
 definst := $(PATH_LIB)
 $(foreach target, $(IMPORT_LIBS) $(IMPORT_LIBS.$(BUILD_TARGET)) $(IMPORT_LIBS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), $(eval $(value def_lib)))
else
 EXT     := DLL
 tool_do := LINK_DLL
 definst := $(PATH_DLL)
 $(foreach target, $(IMPORT_LIBS) $(IMPORT_LIBS.$(BUILD_TARGET)) $(IMPORT_LIBS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), $(eval $(value def_link_common)))
endif

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done import library targets)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# PROGRAMS
#

# Process programs
EXT     := EXE
EXTPRE  :=
tool_do := LINK_PROGRAM
definst := $(PATH_BIN)
typevar := _PROGRAMS
mode    := 0755
bld_trg_base_var := TARGET
$(foreach target, $(PROGRAMS) $(PROGRAMS.$(BUILD_TARGET)) $(PROGRAMS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), $(eval $(value def_link_common)))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done program targets)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# SYSMODS
#

# Process sysmods
EXT     := SYS
EXTPRE  :=
tool_do := LINK_SYSMOD
definst := $(PATH_SYS)
typevar := _SYSMODS
mode    := 0644
bld_trg_base_var := TARGET
$(foreach target, $(SYSMODS) $(SYSMODS.$(BUILD_TARGET)) $(SYSMODS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), $(eval $(value def_link_common)))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done sysmod targets)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# OTHERS
#
_OTHERS = $(OTHERS) $(OTHERS.$(BUILD_TARGET)) $(OTHERS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))


#
# INSTALLS
#

## generate the install rule
define def_install_src_rule
# the install rule
$(insdst) : $(srcsrc) | $(call DIRDEP,$(dir $(insdst)))
	$$(call MSG_INST_FILE,$(srcsrc),$(insdst))
	$$(QUIET)$(inscmd)
endef

## install one file
define def_install_src

# deal with '=>' in the source file name.
srcdst := $(subst =>, ,$(src))
srcsrc := $(firstword $(srcdst))
srcdstdir := $(dir $(word 2,$(srcdst)))
srcdst := $(word $(words $(srcdst)),$(srcdst))

# _INSTFUN
ifdef $(srcsrc)_INSTFUN
 instfun := $(srcsrc)_INSTFUN
else ifdef $(target)_INSTFUN
 instfun := $(target)_INSTFUN
else
 instfun := _INSTALL_FILE
endif

# _INST
ifdef $(srcsrc)_INST
 inst := $(patsubst %/,%,$($(srcsrc)_INST))/$(dir $(srcdstdir))
else ifdef $(target)_INST
 inst := $(patsubst %/,%,$($(target)_INST))/$(dir $(srcdstdir))
else
 inst := $(dir $(srcdstdir))
endif

# calc target
insdst := $(call $(instfun),$(srcdst),$(target),$(inst),$(PATH_INS))
#$(warning instfun=$(instfun) srcdst=$(srcdst) target=$(target) inst=$(inst) => insdst=$(insdst))

# mode, uid and gid
mode := $(firstword \
	$($(target)_$(srcsrc)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_MODE.$(bld_trg)) \
	$($(target)_$(srcsrc)_MODE) \
	$($(target)_$(srcdst)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_MODE.$(bld_trg)) \
	$($(target)_$(srcdst)_MODE) \
	$($(srcsrc)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_MODE.$(bld_trg)) \
	$($(srcsrc)_MODE) \
	$($(srcdst)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(srcdst)_MODE.$(bld_trg)) \
	$($(srcdst)_MODE) \
	$($(target)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_MODE.$(bld_trg)) \
	$($(target)_MODE))
uid := $(firstword \
	$($(target)_$(srcsrc)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_UID.$(bld_trg)) \
	$($(target)_$(srcsrc)_UID) \
	$($(target)_$(srcdst)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_UID.$(bld_trg)) \
	$($(target)_$(srcdst)_UID) \
	$($(srcsrc)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_UID.$(bld_trg)) \
	$($(srcsrc)_UID) \
	$($(srcdst)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcdst)_UID.$(bld_trg)) \
	$($(srcdst)_UID) \
	$($(target)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_UID.$(bld_trg)) \
	$($(target)_UID))
gid := $(firstword \
	$($(target)_$(srcsrc)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_GID.$(bld_trg)) \
	$($(target)_$(srcsrc)_GID) \
	$($(target)_$(srcdst)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_GID.$(bld_trg)) \
	$($(target)_$(srcdst)_GID) \
	$($(srcsrc)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_GID.$(bld_trg)) \
	$($(srcsrc)_GID) \
	$($(srcdst)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcdst)_GID.$(bld_trg)) \
	$($(srcdst)_GID) \
	$($(target)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_GID.$(bld_trg)) \
	$($(target)_GID))
flags := \
	$($(target)_IFFLAGS) \
	$($(target)_IFFLAGS.$(bld_trg)) \
	$($(target)_IFFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(srcdst)_IFFLAGS) \
	$($(srcdst)_IFFLAGS.$(bld_trg)) \
	$($(srcdst)_IFFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_IFFLAGS) \
	$($(srcsrc)_IFFLAGS.$(bld_trg)) \
	$($(srcsrc)_IFFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_IFFLAGS) \
	$($(target)_$(srcdst)_IFFLAGS.$(bld_trg)) \
	$($(target)_$(srcdst)_IFFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_IFFLAGS) \
	$($(target)_$(srcsrc)_IFFLAGS.$(bld_trg)) \
	$($(target)_$(srcsrc)_IFFLAGS.$(bld_trg).$(bld_trg_arch))


# Adjust the source if we got a default PATH. (This must be done this late!)
ifdef $(target)_PATH
 srcsrc := $(abspathex $(srcsrc),$($(target)_PATH))
endif

# create the command
ifdef $(srcsrc)_INSTALLER
 inscmd := $(call $(srcsrc)_INSTALLER,$(srcsrc),$(insdst),$(target),$(flags))
else ifdef $(target)_INSTALLER
 inscmd := $(call $(target)_INSTALLER,$(srcsrc),$(insdst),$(target),$(flags))
else
 inscmd := $$(INSTALL)\
		$(if $(uid),-o $(uid))\
		$(if $(gid),-g $(gid))\
		$(if $(mode),-m $(mode))\
		$(flags)\
		$(srcsrc) $(insdst)
endif

# generate the rule (need double evaluation here)
$(eval $(def_install_src_rule))

INSTARGET_$(target) += $(insdst)
endef


## generate the symlink rule
define def_install_symlink_rule
# the install rule
$(insdst) : | $(call DIRDEP,$(dir $(insdst)))
	$$(call MSG_INST_SYM,$(insdst),$(symdst))
	$$(QUIET)$$(RM) -f $$@
	$$(QUIET)$$(LN_SYMLINK) $(symdst) $(insdst)
endef

## create one symlink
define def_install_symlink

# deal with '=>' in the source file name.
symdst := $(subst =>, ,$(src))
symlnk := $(firstword $(symdst))
symdst := $(word $(words $(symdst)),$(symdst))

# _INSTFUN
ifdef $(symlnk)_INSTFUN
 instfun := $(symlnk)_INSTFUN
else ifdef $(target)_INSTFUN
 instfun := $(target)_INSTFUN
else
 instfun := _INSTALL_FILE
endif

# _INST
ifdef $(symlnk)_INST
 inst := $(patsubst %/,%,$($(symlnk)_INST))/$(dir $(symlnk))
else ifdef $(target)_INST
 inst := $(patsubst %/,%,$($(target)_INST))/$(dir $(symlnk))
else
 inst := $(dir $(symlnk))
endif

# calc target
insdst := $(call $(instfun),$(symlnk),$(target),$(inst),$(PATH_INS))
#$(warning symlnk=$(symlnk) symdst=$(symdst) insdst=$(insdst) instfun=$(instfun) inst='$(inst)')

# generate the rule (need double evaluation here)
$(eval $(def_install_symlink_rule))

INSTARGET_$(target) += $(insdst)
endef


## generate the install rule
define def_install_directory_rule
# the install rule
$(insdst):
	$$(call MSG_INST_DIR,$(insdst))
	$$(QUIET)$$(INSTALL) -d \
		$(if $(uid),-o $(uid))\
		$(if $(gid),-g $(gid))\
		$(if $(mode),-m $(mode))\
		$(flags)\
		$(insdst)

.NOTPARALLEL: $(insdst)
endef


## create one directory
define def_install_directory

# _INST
ifdef $(directory)_INST
 inst := $(PATH_INS)/$(patsubst %/,%,$($(directory)_INST))
else ifdef $(target)_INST
 inst := $(PATH_INS)/$(patsubst %/,%,$($(target)_INST))
else
 inst := $(PATH_INS)
endif

mode := $(firstword \
	$($(target)_$(directory)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_MODE.$(bld_trg)) \
	$($(target)_$(directory)_MODE) \
	$($(directory)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(directory)_MODE.$(bld_trg)) \
	$($(directory)_MODE) \
	$($(target)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_MODE.$(bld_trg)) \
	$($(target)_MODE))
uid := $(firstword \
	$($(target)_$(directory)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_UID.$(bld_trg)) \
	$($(target)_$(directory)_UID) \
	$($(directory)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(directory)_UID.$(bld_trg)) \
	$($(directory)_UID) \
	$($(target)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_UID.$(bld_trg)) \
	$($(target)_UID))
gid := $(firstword \
	$($(target)_$(directory)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_GID.$(bld_trg)) \
	$($(target)_$(directory)_GID) \
	$($(directory)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(directory)_GID.$(bld_trg)) \
	$($(directory)_GID) \
	$($(target)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_GID.$(bld_trg)) \
	$($(target)_GID))
flags := \
	$($(target)_IDFLAGS)\
	$($(target)_IDFLAGS.$(bld_trg)) \
	$($(target)_IDFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(directory)_IDFLAGS) \
	$($(directory)_IDFLAGS.$(bld_trg)) \
	$($(directory)_IDFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_IDFLAGS) \
	$($(target)_$(directory)_IDFLAGS.$(bld_trg)) \
	$($(target)_$(directory)_IDFLAGS.$(bld_trg).$(bld_trg_arch))

insdst := $(inst)/$(directory)/
#$(warning directory=$(directory) inst=$(inst) insdst=$(insdst) mode=$(mode) gid=$(gid) uid=$(uid))

# generate the rule (need double evaluation here)
$(eval $(def_install_directory_rule))

INSTARGET_DIRS_$(target) += $(insdst)
endef


## process one install target.
define def_install
# the basics.
bld_type  := $(firstword $($(target)_BLD_TYPE)     $(BUILD_TYPE))
bld_trg   := $(firstword $($(target)_BLD_TRG)      $(BUILD_TARGET))
bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(BUILD_TARGET_ARCH))
bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(BUILD_TARGET_CPU))

INSTARGET_$(target) := $($(target)_GOALS)
INSTARGET_DIRS_$(target) :=

$(foreach directory,$($(target)_DIRS) $($(target)_DIRS.$(bld_trg)) $($(target)_DIRS.$(bld_trg).$(bld_trg_arch)) $($(target)_DIRS.$(bld_trg_arch)) $($(target)_DIRS.$(bld_trg_cpu)) $($(target)_DIRS.$(bld_type)), \
	$(eval $(value def_install_directory)))

$(foreach src,$($(target)_SOURCES) $($(target)_SOURCES.$(bld_trg)) $($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_cpu)) $($(target)_SOURCES.$(bld_type)), \
	$(eval $(value def_install_src)))

$(foreach src,$($(target)_SYMLINKS) $($(target)_SYMLINKS.$(bld_trg)) $($(target)_SYMLINKS.$(bld_trg).$(bld_trg_arch)) $($(target)_SYMLINKS.$(bld_trg_arch)) $($(target)_SYMLINKS.$(bld_trg_cpu)) $($(target)_SYMLINKS.$(bld_type)), \
	$(eval $(value def_install_symlink)))

# the collection target
TARGET_$(target) := $(PATH_TARGET)/$(target).ins
$(TARGET_$(target)): $(INSTARGET_$(target)) | $(INSTARGET_DIRS_$(target)) $(call DIRDEP,$(PATH_TARGET))
	@$(QUIET2)$(APPEND) $@

$(target): $(TARGET_$(target))

_INSTALLS += $(TARGET_$(target))
_INSTALLS_FILES += $(INSTARGET_$(target))
_INSTALLS_DIRS += $(INSTARGET_DIRS_$(target))
_CLEAN_FILES += $($(target)_CLEAN) $($(target)_CLEAN.$(bld_trg)) $($(target)_CLEAN.$(bld_trg).$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_cpu)) $($(target)_CLEAN.$(bld_type))
_DIRS += $($(target)_BLDDIRS) $($(target)_BLDDIRS.$(bld_trg)) $($(target)_BLDDIRS.$(bld_trg).$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_cpu)) $($(target)_BLDDIRS.$(bld_type))
endef

## process all install targets
$(foreach target, $(INSTALLS) $(INSTALLS.$(BUILD_TARGET)) $(INSTALLS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)), \
	$(eval $(value def_install)))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done install targets)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# PACKING
#
_PACKING += $(PACKING) $(PACKING.$(BUILD_TARGET)) $(PACKING.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))


#
# DOCS
#


#
# DIRECTORIES
#
_DIR_ALL := $(sort $(addsuffix /,$(patsubst %/,%,$(_DIRS))) $(dir $(_OUT_FILES) $(_OBJS) $(_INSTALLS_FILES)))
$(foreach directory,$(_INSTALLS_DIRS), $(eval _DIR_ALL := $(filter-out $(directory),$(_DIR_ALL))))


define def_mkdir_rule
$(directory):
	$$(call MSG_MKDIR,$$@)
	$$(QUIET)$$(MKDIR) -p $$@
endef

$(foreach directory,$(_DIR_ALL),$(eval $(def_mkdir_rule)))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done directories)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# NOTHING
#
do-nothing:
ifdef KBUILD_PROFILE_SELF
	@$(ECHO) 'prof: $(int-sub $(nanots ), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(nanots ), $(_KBUILD_TS_PREV)) - executing $@'
endif
	$(call MSG_NOTHING)


#
# CLEAN UP
#
do-clean:
	$(call MSG_CLEAN)
	$(QUIET)$(RM) -f $(_OUT_FILES) $(_OBJS) $(_DEPFILES) $(_DEPFILES_INCLUDED) $(_CLEAN_FILES) $(OTHER_CLEAN)
	$(QUIET)$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist $(rsort $(dir $(_OUT_FILES) $(_OBJS) $(_DEPFILES) $(_DEPFILES_INCLUDED) $(_CLEAN_FILES) $(OTHER_CLEAN)))



#
# PASSES (including directory and makefile walking)
#

## Subdir
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
# @param	$(subdir)	Subdirectory
# @param	$(tag)		tag to attach to the rule name.
define def_pass_subdir
pass_$(pass)$(tag):: $(dep)
	+ $$(QUIET)$$(MAKE) -C $(subdir) -f $$(notdir $$(firstword $$(wildcard $$(addprefix $(subdir)/,$$(DEFAULT_MAKEFILE))))) pass_$(pass)
endef

## Submakefile
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
# @param	$(makefile) Makefile.
# @param	$(tag)		tag to attach to the rule name.
define def_pass_makefile
pass_$(pass)$(tag):: $(dep)
	+ $$(QUIET)$$(MAKE) -C $(patsubst %/,%,$(dir $(makefile))) -f $(notdir $(makefile)) pass_$(pass)
endef

## Execute a pass.
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
define def_pass_old
$(eval SUBDIRS_$(PASS)          ?= $(SUBDIRS)          $(SUBDIRS.$(BUILD_TARGET))           $(SUBDIRS.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))          )
$(eval SUBDIRS_AFTER_$(PASS)    ?= $(SUBDIRS_AFTER)    $(SUBDIRS_AFTER.$(BUILD_TARGET))     $(SUBDIRS_AFTER.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))    )
$(eval MAKEFILES_BEFORE_$(PASS) ?= $(MAKEFILES_BEFORE) $(MAKEFILES_BEFORE.$(BUILD_TARGET))  $(MAKEFILES_BEFORE.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)) )
$(eval MAKEFILES_AFTER_$(PASS)  ?= $(MAKEFILES_AFTER)  $(MAKEFILES_AFTER.$(BUILD_TARGET))   $(MAKEFILES_AFTER.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))  )

$(eval tag:=_before)
$(eval dep:=)
$(foreach subdir,$(SUBDIRS_$(PASS))            $(SUBDIRS_$(PASS).$(BUILD_TARGET))           $(SUBDIRS_$(PASS).$(BUILD_TARGET).$(BUILD_TARGET_ARCH))         ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_BEFORE_$(PASS)) $(MAKEFILES_BEFORE_$(PASS).$(BUILD_TARGET))  $(MAKEFILES_BEFORE_$(PASS).$(BUILD_TARGET).$(BUILD_TARGET_ARCH)),$(eval $(def_pass_makefile)))

$(eval tag:=_after)
$(eval dep:=pass_$(pass)_doit)
$(foreach subdir,$(SUBDIRS_AFTER_$(PASS))      $(SUBDIRS_AFTER_$(PASS).$(BUILD_TARGET))     $(SUBDIRS_AFTER_$(PASS).$(BUILD_TARGET).$(BUILD_TARGET_ARCH))   ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_AFTER_$(PASS))  $(MAKEFILES_AFTER_$(PASS).$(BUILD_TARGET))   $(MAKEFILES_AFTER_$(PASS).$(BUILD_TARGET).$(BUILD_TARGET_ARCH)) ,$(eval $(def_pass_makefile)))

.NOTPARALLEL: pass_$(pass)_before pass_$(pass)_after
.PHONY: pass_$(pass) pass_$(pass)_before pass_$(pass)_doit pass_$(pass)_after
pass_$(pass)_doit: 	$(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$(var))
pass_$(pass)_this:      pass_$(pass)_before
	+ $$(QUIET)$$(MAKE) -f $$(MAKEFILE) pass_$(pass)_doit
pass_$(pass)_after::    pass_$(pass)_this
pass_$(pass):           pass_$(pass)_after

endef

define def_pass
$(eval SUBDIRS_$(PASS)          ?= $(SUBDIRS)          $(SUBDIRS.$(BUILD_TARGET))          $(SUBDIRS.$(BUILD_TARGET.$(BUILD_TARGET_ARCH)))          )
$(eval SUBDIRS_AFTER_$(PASS)    ?= $(SUBDIRS_AFTER)    $(SUBDIRS_AFTER.$(BUILD_TARGET))    $(SUBDIRS_AFTER.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))    )
$(eval MAKEFILES_BEFORE_$(PASS) ?= $(MAKEFILES_BEFORE) $(MAKEFILES_BEFORE.$(BUILD_TARGET)) $(MAKEFILES_BEFORE.$(BUILD_TARGET).$(BUILD_TARGET_ARCH)) )
$(eval MAKEFILES_AFTER_$(PASS)  ?= $(MAKEFILES_AFTER)  $(MAKEFILES_AFTER.$(BUILD_TARGET))  $(MAKEFILES_AFTER.$(BUILD_TARGET).$(BUILD_TARGET_ARCH))  )

$(eval tag:=_before)
$(eval dep:=)
$(foreach subdir,$(SUBDIRS_$(PASS))            $(SUBDIRS_$(PASS).$(BUILD_TARGET))          $(SUBDIRS_$(PASS).$(BUILD_TARGET).$(BUILD_TARGET_ARCH))         ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_BEFORE_$(PASS)) $(MAKEFILES_BEFORE_$(PASS).$(BUILD_TARGET)) $(MAKEFILES_BEFORE_$(PASS).$(BUILD_TARGET).$(BUILD_TARGET_ARCH)),$(eval $(def_pass_makefile)))

$(eval tag:=_after)
$(eval dep:=pass_$(pass)_doit)
$(foreach subdir,$(SUBDIRS_AFTER_$(PASS))      $(SUBDIRS_AFTER_$(PASS).$(BUILD_TARGET))    $(SUBDIRS_AFTER_$(PASS).$(BUILD_TARGET).$(BUILD_TARGET_ARCH))   ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_AFTER_$(PASS))  $(MAKEFILES_AFTER_$(PASS).$(BUILD_TARGET))  $(MAKEFILES_AFTER_$(PASS).$(BUILD_TARGET).$(BUILD_TARGET_ARCH)) ,$(eval $(def_pass_makefile)))

ifdef KBUILD_SAFE_PARALLEL
.NOTPARALLEL: pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_this
.PHONY:       pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_this pass_$(pass)_doit
pass_$(pass)_doit: 	    $(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$(var))
pass_$(pass)_this:      pass_$(pass)_before
	+ $$(QUIET)$$(MAKE) -f $$(MAKEFILE) pass_$(pass)_doit
pass_$(pass)_after::    pass_$(pass)_this
pass_$(pass):           pass_$(pass)_after
else
.NOTPARALLEL: pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_doit
.PHONY:       pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_doit
pass_$(pass)_doit: pass_$(pass)_before \
		$(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$($(var)))
pass_$(pass): \
		pass_$(pass)_before \
		pass_$(pass)_doit \
        pass_$(pass)_after
endif

#$ (warning pass=$(pass) PASS=$(PASS): $(PASS_$(PASS)_trgs) $(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$($(var))))
endef

# Generate the defined passes.
$(foreach PASS, $(PASSES), \
	$(eval pass := $(PASS_$(PASS)_pass)) \
	$(eval $(def_pass)))

## Pass order
# @param	$(pass)		Current pass name.
# @param	$(prev_pass)	The previous pass name.
define def_pass_order
ifdef KBUILD_SAFE_PARALLEL
.NOTPARALLEL: pass_$(pass)_order
.PHONY: pass_$(pass)_order
pass_$(pass)_order: $(pass_prev)
	$$(call MSG_PASS,$$(if $$(PASS_$(PASS)),$$(PASS_$(PASS)),$(pass)))
	+ $$(QUIET)$$(MAKE) -f $$(MAKEFILE) pass_$(pass)
else
.NOTPARALLEL: pass_$(pass)_order pass_$(pass)_banner
.PHONY:       pass_$(pass)_order pass_$(pass)_banner
pass_$(pass)_banner:
	$$(call MSG_PASS,$$(if $$(PASS_$(PASS)),$$(PASS_$(PASS)),$(pass)))
pass_$(pass)_order: \
		$(pass_prev) \
		pass_$(pass)_banner \
		pass_$(pass)
endif
$(eval pass_prev := pass_$(pass)_order)
endef

## PASS: order
# Use dependencies to ensure correct pass order.
pass_prev :=
$(foreach PASS,$(DEFAULT_PASSES),\
	$(eval pass := $(PASS_$(PASS)_pass)) \
	$(eval $(def_pass_order)))

ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_NOW := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_NOW), $(_KBUILD_TS_PREV)) - done passes)
 _KBUILD_TS_PREV := $(_KBUILD_TS_NOW)
endif


#
# THE MAIN RULES
#
all_recursive: $(pass_prev)

rebuild: clean
	+ $(MAKE) -f $(firstword $(MAKEFILE_LIST)) all_recursive

# @todo make this a non-default pass!
uninstall:
	$(RM) -f $(_INSTALLS_FILES)

install: pass_installs

# misc shortcuts.
targets:   bldprogs libraries dlls programs sysmods others installs
objects:   $(_OBJS)
bldprogs:  $(_BLDPROGS)
libraries: $(_LIBS) $(_IMPORT_LIBS) $(_OTHER_LIBRARIES)
dlls:      $(_DLLS)
programs:  $(_PROGRAMS)
sysmods:   $(_SYSMODS)
others:    $(_OTHERS)
installs:  $(_INSTALLS) $(_INSTALLS_DIRS) $(_INSTALLS_FILES)



#
# kBuild debugging stuff.
#
show_targets:
	@$(foreach target, $(_ALL_TARGETS),\
	@$(ECHO) "target: $(target)" $(NLTAB)\
	@$(ECHO) "  PATH_$(target)=$(PATH_$(target))" $(NLTAB)\
	@$(ECHO) "  TARGET_$(target)=$(TARGET_$(target))" $(NLTAB)\
	@$(ECHO) "  INSTARGET_$(target)=$(INSTARGET_$(target))" $(NLTAB)\
$(foreach prop,$(PROPS_SINGLE) $(PROPS_ACCUMULATE_L) $(PROPS_ACCUMULATE_R) OBJS_ CLEAN, \
	$(eval _tmp:=$(firstword $($(target)_BLD_TRG) $(BUILD_TARGET))) \
	$(if $($(target)_$(prop).$(_tmp)),\
		@$(ECHO) "  $(target)_$(prop).$(_tmp)=$($(target)_$(prop).$(_tmp))" $(NLTAB)) \
	$(if $($(target)_$(prop)), $(NLTAB)@$(ECHO) "  $(target)_$(prop)=$($(target)_$(prop))" $(NLTAB)) \
)\
$(foreach prop,$(PROPS_DEFERRED), \
	$(eval _tmp:=$(firstword $($(target)_BLD_TRG) $(BUILD_TARGET))) \
	$(if $(value $(target)_$(prop).$(_tmp)),\
		@$(ECHO) '  $(target)_$(prop).$(_tmp)=$(value $(TARGET)_$(prop).$(_tmp))' $(NLTAB)) \
	$(if $(value $(target)_$(prop)), $(NLTAB)@$(ECHO) '  $(target)_$(prop)=$(value $(target)_$(prop))' $(NLTAB)) \
))



#
# Include dependency files.
#
ifneq ($(_DEPFILES),)
 includedep $(_DEPFILES)
endif


ifdef KBUILD_PROFILE_SELF
 _KBUILD_TS_FOOTER_END := $(nanots )
 $(info prof: $(int-sub $(_KBUILD_TS_FOOTER_END), $(_KBUILD_TS_HEADER_START)) - $(int-sub $(_KBUILD_TS_FOOTER_END), $(_KBUILD_TS_PREV)) - end of footer.kmk)
 $(info prof: footer.kmk: $(int-sub $(_KBUILD_TS_FOOTER_END), $(_KBUILD_TS_FOOTER_START)))
 _KBUILD_TS_PREV := $(_KBUILD_TS_FOOTER_END)
endif

# end-of-file-content
__footer_kmk__ := target
endif # __footer_kmk__

