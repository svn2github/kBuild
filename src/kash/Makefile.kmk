# $Id$
## @file
# kBuild Makefile for kash.
#

#
# Copyright (c) 2005-2008 knut st. osmundsen <bird-src-spam@anduin.net>
#
# This file is part of kBuild.
#
# kBuild is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# kBuild is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with kBuild; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
#

DEPTH = ../..
include $(PATH_KBUILD)/header.kmk

#
# The program.
#
PROGRAMS += kash
kash_TEMPLATE = BIN
kash_DEFS = lint SHELL SMALL
kash_DEFS += SH_STUB_MODE # for the time being.
kash_DEFS.debug = DEBUG
kash_DEFS.linux = BSD
kash_DEFS.solaris = BSD
kash_DEFS.win = \
	BSD PC_PATH_SEP PC_DRIVE_LETTERS PC_EXE_EXTS YY_NO_UNISTD_H
kash_DEFS.os2 = \
	HAVE_SYS_SIGNAME HAVE_SYSCTL_H HAVE_SETPROGNAME \
	EXEC_HASH_BANG_SCRIPT PC_OS2_LIBPATHS PC_PATH_SEP PC_DRIVE_LETTERS PC_EXE_EXTS
kash_DEFS.darwin = \
	HAVE_SYS_SIGNAME HAVE_SYSCTL_H HAVE_SETPROGNAME
kash_DEFS.freebsd = \
	HAVE_SYS_SIGNAME HAVE_SYSCTL_H HAVE_SETPROGNAME
kash_INCS = $(PATH_TARGET) . # (the last is because of error.h)
kash_SOURCES = \
	main.c \
	alias.c \
	cd.c \
	error.c \
	eval.c \
	exec.c \
	expand.c \
	histedit.c \
	input.c \
	jobs.c \
	mail.c \
	memalloc.c \
	mystring.c \
	options.c \
	output.c \
	parser.c \
	redir.c \
	show.c \
	syntax.c \
	trap.c \
	var.c \
	miscbltin.c \
	bltin/echo.c \
	bltin/kill.c \
	bltin/test.c \
	\
	$(PATH_TARGET)/arith.c \
	$(PATH_TARGET)/arith_lex.c \
	$(PATH_TARGET)/builtins.c \
	$(PATH_TARGET)/init.c \
	$(PATH_TARGET)/nodes.c \
	\
	setmode.c \
	shinstance.c \
	shthread.c \
	shfile.c
kash_SOURCES.linux = \
	sys_signame.c \
	strlcpy.c
kash_SOURCES.win = \
	sys_signame.c \
	strlcpy.c
kash_SOURCES.solaris = \
	sys_signame.c \
	strlcpy.c

kash_ORDERDEPS = \
	$(PATH_TARGET)/arith.h \
	$(PATH_TARGET)/builtins.h \
	$(PATH_TARGET)/nodes.h \
	$(PATH_TARGET)/token.h
kash_CLEAN = \
	$(kash_ORDERDEPS)	\
	$(PATH_TARGET)/arith.c \
	$(PATH_TARGET)/arith_lex.c \
	$(PATH_TARGET)/builtins.c \
	$(PATH_TARGET)/init.c \
	$(PATH_TARGET)/nodes.c

##
## The manual page.
##
#INSTALLS += kash.man
#kash.man_TEMPLATE = usr.bin.man
#kash.man_SOURCES = sh.1=>kash.1


ifeq ($(filter-out win,$(KBUILD_TARGET)),)

#
# Use the pregenerated code.
#
kash_ORDERDEPS :=
kash_INCS += generated
kash_SOURCES := $(patsubst $(PATH_TARGET)/%,generated/%,$(kash_SOURCES))

include $(FILE_KBUILD_FOOTER)

else

include $(FILE_KBUILD_FOOTER)

#
# ATTENTION! ATTENTION! ATTENTION!
#
# Older ash versions has trouble with some of these scripts, great.
# Kudos to the NetBSD guys for this clever move. ;)
#
# So, when building for the frist time, setting BOOSTRAP_SHELL=/bin/bash is good idea.
#
BOOTSTRAP_SHELL ?= $(SHELL)
YACC ?= yacc

$(PATH_TARGET)/arith.h $(PATH_TARGET)/arith.c: arith.y | $(call DIRDEP,$(PATH_TARGET))
	$(YACC) -ld $^
	$(MV) -f y.tab.c $(PATH_TARGET)/arith.c
	$(MV) -f y.tab.h $(PATH_TARGET)/arith.h

$(PATH_TARGET)/arith_lex.c: arith_lex.l | $(call DIRDEP,$(PATH_TARGET))
	flex -8 -o$@ $^                     # 8-bit lex scanner for arithmetic

$(PATH_TARGET)/builtins.h $(PATH_TARGET)/builtins.c: $(PATH_CURRENT)/mkbuiltins shell.h builtins.def | $(call DIRDEP,$(PATH_TARGET))
	$(BOOTSTRAP_SHELL) $+ $(dir $@)
	[ -f $(PATH_TARGET)/builtins.h ]

$(PATH_TARGET)/nodes.h $(PATH_TARGET)/nodes.c: $(PATH_CURRENT)/mknodes.sh nodetypes nodes.c.pat | $(call DIRDEP,$(PATH_TARGET))
	$(BOOTSTRAP_SHELL) $+ $(dir $@)
	[ -f $(dir $@)/nodes.h ]

$(PATH_TARGET)/token.h: $(PATH_CURRENT)/mktokens | $(call DIRDEP,$(PATH_TARGET))
	$(BOOTSTRAP_SHELL) $+
	$(MV) token.h $@

$(PATH_TARGET)/init.c: $(PATH_CURRENT)/mkinit.sh $(filter-out $(PATH_TARGET)/%,$(kash_SOURCES)) | $(call DIRDEP,$(PATH_TARGET))
	$(BOOTSTRAP_SHELL) $+
	$(MV) init.c $@

endif
