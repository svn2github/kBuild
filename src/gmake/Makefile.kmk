# $Id$


#
# kmk
#
PROGRAMS           += kmk

kmk_TEMPLATE        = BIN
kmk_DEPS            = $(PATH_TARGET)/config.h
kmk_INCS            = $(PATH_TARGET) .
#kmk_INCS.win32      = kmkbuiltin/w32

kmk_DEFS            = \
	HAVE_CONFIG_H \
    NO_ARCHIVES \
	CONFIG_NO_DEFAULT_SUFFIXES \
	CONFIG_NO_DEFAULT_PATTERN_RULES	\
	CONFIG_NO_DEFAULT_TERMINAL_RULES \
	CONFIG_NO_DEFAULT_SUFFIX_RULES \
	CONFIG_NO_DEFAULT_VARIABLES \
	KMK
	
kmk_SOURCES         = \
	main.c \
	read.c \
	hash.c \
	variable.c \
	ar.c \
	arscan.c \
	commands.c \
	default.c \
	dir.c \
	expand.c \
	file.c \
	function.c \
	implicit.c \
	job.c \
	misc.c \
	remake.c \
	rule.c \
	signame.c \
	version.c \
	vpath.c \
	remote-stub.c

kmk_SOURCES.win32 = \
	getopt.c \
	getopt1.c \
	getloadavg.c \
	w32/subproc/misc.c \
	w32/subproc/sub_proc.c \
	w32/subproc/w32err.c \
	glob/glob.c \
	glob/fnmatch.c \
	w32/compat/dirent.c \
	w32/pathstuff.c

kmk_SOURCES.freebsd = \
	glob/glob.c \
	glob/fnmatch.c \

ifneq ($(BUILD_TARGET),win32)
#
# kmkbuiltin commands
#
kmk_DEFS += CONFIG_WITH_KMK_BUILTIN
kmk_SOURCES += \
	kmkbuiltin.c \
	kmkbuiltin/echo.c \
	kmkbuiltin/mkdir.c \
	kmkbuiltin/rm.c \
	kmkbuiltin/cp.c \
	kmkbuiltin/cp_utils.c \
	\
	kmkbuiltin/setmode.c \
	kmkbuiltin/strmode.c \
	kmkbuiltin/strlcpy.c


#
# Standalone kmkbuiltin commands.
#
PROGRAMS += cp echo mkdir rm

cp_TEMPLATE = BIN
cp_DEFS = kmk_builtin_cp=main
cp_SOURCES = \
	kmkbuiltin/cp.c \
	kmkbuiltin/cp_utils.c \
    kmkbuiltin/strlcpy.c

echo_TEMPLATE = BIN
echo_DEFS = kmk_builtin_echo=main
echo_SOURCES = \
	kmkbuiltin/echo.c

mkdir_TEMPLATE = BIN
mkdir_DEFS = kmk_builtin_mkdir=main
mkdir_SOURCES = \
	kmkbuiltin/mkdir.c \
	kmkbuiltin/setmode.c

rm_TEMPLATE = BIN
rm_DEFS = kmk_builtin_rm=main
rm_SOURCES = \
	kmkbuiltin/rm.c \
	kmkbuiltin/setmode.c \
	kmkbuiltin/strmode.c
endif


DEPTH = ../..
include $(PATH_KBUILD)/rules.kmk

			
#
# Use checked in config.h instead of running ./Configure for it.
#			
$(PATH_TARGET)/config.h: config.h.$(BUILD_TARGET)
	$(MKDIR) -p $(dir $@)
	$(CP) $^ $@


#
# Some tests.
#
parallel: parallel_1 parallel_2 parallel_3 parallel_4 parallel_5
parallel_1 parallel_2 parallel_3 parallel_4 parallel_5:
	echo $@_start ; sleep 1; echo $@_done

test:
	echo "1"
	echo "2"
	echo "3"
	echo "4"

