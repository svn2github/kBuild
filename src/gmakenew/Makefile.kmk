# $Id$


DEPTH = ../..
PATH_GNUMAKE_SRC = $(PATH_ROOT)/src/gmakenew
include $(PATH_KBUILD)/header.kmk


#
# Template for kmk and the kmk_* binaries in this makefile.
#
TEMPLATE_BIN-KMK = Template for src/gmake binaries
TEMPLATE_BIN-KMK_EXTENDS = BIN
TEMPLATE_BIN-KMK_DEFS = HAVE_CONFIG_H $(TEMPLATE_BIN_DEFS)
TEMPLATE_BIN-KMK_DEPS = $(PATH_TARGET)/config.h
TEMPLATE_BIN-KMK_CLEAN = $(TEMPLATE_BIN-KMK_DEPS)
TEMPLATE_BIN-KMK_DEPS.solaris = \
	$(PATH_TARGET)/fts.h \
	$(PATH_TARGET)/paths.h
TEMPLATE_BIN-KMK_CLEAN.solaris = $(TEMPLATE_BIN-KMK_DEPS.solaris)
TEMPLATE_BIN-KMK_DEPS.win     = \
	$(PATH_TARGET)/fts.h \
	$(PATH_TARGET)/sysexits.h \
	$(PATH_TARGET)/unistd.h \
	$(PATH_TARGET)/paths.h \
	$(PATH_TARGET)/grp.h \
	$(PATH_TARGET)/pwd.h \
	$(PATH_TARGET)/inttypes.h
TEMPLATE_BIN-KMK_CLEAN.win = $(TEMPLATE_BIN-KMK_DEPS.win)
TEMPLATE_BIN-KMK_INCS = $(PATH_TARGET) . $(TEMPLATE_BIN_INCS)
TEMPLATE_BIN-KMK_INCS.darwin = glob
TEMPLATE_BIN-KMK_INCS.freebsd = glob
TEMPLATE_BIN-KMK_INCS.solaris = glob
TEMPLATE_BIN-KMK_LIBS = $(TEMPLATE_BIN_LIBS) $(TARGET_kmkmissing)
ifdef ELECTRIC_HEAP # for electric heap (see electric.c) - windows only.
TEMPLATE_BIN-KMK_CFLAGS = $(TEMPLATE_BIN_CFLAGS) /FI$(PATH_CURRENT)/electric.h -DELECTRIC_HEAP=1
endif


#
# A library containing the missing features needed by kmk and the
# kmk_* binaries. Saves a bit of work later on.
#
LIBRARIES += kmkmissing
kmkmissing_TEMPLATE = BIN-KMK
kmkmissing_NOINST = 1
kmkmissing_SOURCES = \
	kmkbuiltin/err.c \
	kmkbuiltin/setmode.c \
	kmkbuiltin/strmode.c \
	kmkbuiltin/strlcpy.c \
	getopt.c \
	getopt1.c \
	electric.c

kmkmissing_SOURCES.darwin = \
	kmkbuiltin/darwin.c \
	glob/glob.c \
	glob/fnmatch.c

kmkmissing_SOURCES.freebsd = \
	glob/glob.c \
	glob/fnmatch.c

kmkmissing_SOURCES.solaris = \
	kmkbuiltin/solfakes.c \
	kmkbuiltin/fts.c \
	glob/glob.c \
	glob/fnmatch.c

kmkmissing_SOURCES.win += \
	kmkbuiltin/mscfakes.c \
	kmkbuiltin/fts.c
	glob/glob.c \
	glob/fnmatch.c \
	getloadavg.c \
	w32/subproc/misc.c \
	w32/subproc/sub_proc.c \
	w32/subproc/w32err.c \
	w32/compat/dirent.c \
	w32/pathstuff.c

#
# kmk
#
PROGRAMS += kmk

kmk_TEMPLATE = BIN-KMK

kmk_DEFS = \
	NO_ARCHIVES \
	EXPERIMENTAL \
	CONFIG_WITH_TOUPPER_TOLOWER \
	CONFIG_WITH_EXPLICIT_MULTITARGET \
	CONFIG_WITH_PREPEND_ASSIGNMENT \
	\
	KMK \
	KMK_HELPERS \
	VARIABLE_HASH \
	CONFIG_NO_DEFAULT_SUFFIXES \
	CONFIG_NO_DEFAULT_PATTERN_RULES	\
	CONFIG_NO_DEFAULT_TERMINAL_RULES \
	CONFIG_NO_DEFAULT_SUFFIX_RULES \
	CONFIG_NO_DEFAULT_VARIABLES \
	CONFIG_WITH_EXTENDED_NOTPARALLEL \
	CONFIG_WITH_INCLUDEDEP \
	CONFIG_WITH_VALUE_LENGTH \
	CONFIG_WITH_RSORT \
	CONFIG_WITH_ABSPATHEX \
	CONFIG_WITH_COMPARE \
	CONFIG_WITH_STACK \
	CONFIG_WITH_MATH \
	CONFIG_WITH_XARGS \
	CONFIG_PRETTY_COMMAND_PRINTING \
	\
	BUILD_PLATFORM=\"$(BUILD_TARGET)\" \
	BUILD_PLATFORM_ARCH=\"$(BUILD_TARGET_ARCH)\" \
	BUILD_PLATFORM_CPU=\"$(BUILD_TARGET_CPU)\"
kmk_DEFS.x86 = CONFIG_WITH_OPTIMIZATION_HACKS
kmk_DEFS.amd64 = CONFIG_WITH_OPTIMIZATION_HACKS
kmk_DEFS.win.x86 = \
	CONFIG_NEW_WIN32_CTRL_EVENT

kmk_SOURCES = \
	main.c \
	read.c \
	hash.c \
	strcache.c \
	variable.c \
	ar.c \
	arscan.c \
	commands.c \
	default.c \
	dir.c \
	expand.c \
	file.c \
	function.c \
	implicit.c \
	job.c \
	misc.c \
	remake.c \
	rule.c \
	signame.c \
	version.c \
	vpath.c \
	remote-stub.c \
	kbuild.c

#
# kmkbuiltin commands
#
kmk_DEFS += CONFIG_WITH_KMK_BUILTIN
kmk_SOURCES += \
	kmkbuiltin.c \
	kmkbuiltin/append.c \
	kmkbuiltin/cat.c \
	kmkbuiltin/cp.c \
	kmkbuiltin/cp_utils.c \
	kmkbuiltin/echo.c \
	kmkbuiltin/install.c \
	kmkbuiltin/mkdir.c \
	kmkbuiltin/mv.c \
	kmkbuiltin/ln.c \
	kmkbuiltin/printf.c \
	kmkbuiltin/rm.c \
	kmkbuiltin/rmdir.c \


#
# Standalone kmkbuiltin commands.
#
## @todo should probably put all those
PROGRAMS += kmk_append kmk_cat kmk_cp kmk_echo kmk_mkdir kmk_mv kmk_install kmk_ln kmk_printf kmk_rm kmk_rmdir

kmk_append_TEMPLATE = BIN-KMK
kmk_append_DEFS = kmk_builtin_append=main
kmk_append_INCS = .
kmk_append_SOURCES = \
	kmkbuiltin/append.c

kmk_cat_TEMPLATE = BIN-KMK
kmk_cat_DEFS = kmk_builtin_cat=main
kmk_cat_SOURCES = \
	kmkbuiltin/cat.c

kmk_cp_TEMPLATE = BIN-KMK
kmk_cp_DEFS = kmk_builtin_cp=main
kmk_cp_SOURCES = \
	kmkbuiltin/cp.c \
	kmkbuiltin/cp_utils.c

kmk_echo_TEMPLATE = BIN-KMK
kmk_echo_DEFS = kmk_builtin_echo=main
kmk_echo_SOURCES = \
	kmkbuiltin/echo.c

kmk_install_TEMPLATE = BIN-KMK
kmk_install_DEFS = kmk_builtin_install=main
kmk_install_SOURCES = \
	kmkbuiltin/install.c

kmk_ln_TEMPLATE = BIN-KMK
kmk_ln_DEFS = kmk_builtin_ln=main
kmk_ln_SOURCES = \
	kmkbuiltin/ln.c

kmk_mkdir_TEMPLATE = BIN-KMK
kmk_mkdir_DEFS = kmk_builtin_mkdir=main
kmk_mkdir_SOURCES = \
	kmkbuiltin/mkdir.c

kmk_mv_TEMPLATE = BIN-KMK
kmk_mv_DEFS = kmk_builtin_mv=main
kmk_mv_SOURCES = \
	kmkbuiltin/mv.c

kmk_printf_TEMPLATE = BIN-KMK
kmk_printf_DEFS = kmk_builtin_printf=main
kmk_printf_SOURCES = \
	kmkbuiltin/printf.c

kmk_rm_TEMPLATE = BIN-KMK
kmk_rm_DEFS = kmk_builtin_rm=main
kmk_rm_SOURCES = \
	kmkbuiltin/rm.c

kmk_rmdir_TEMPLATE = BIN-KMK
kmk_rmdir_DEFS = kmk_builtin_rmdir=main
kmk_rmdir_SOURCES = \
	kmkbuiltin/rmdir.c


#
# kmk_gmake - almost plain GNU Make.
#
PROGRAMS += kmk_gmake

kmk_gmake_TEMPLATE = BIN-KMK
kmk_gmake_DEFS = \
	HAVE_CONFIG_H \
	NO_ARCHIVES \
	CONFIG_WITH_TOUPPER_TOLOWER \
	EXPERIMENTAL

kmk_gmake_SOURCES = \
	main.c \
	read.c \
	hash.c \
	strcache.c \
	variable.c \
	ar.c \
	arscan.c \
	commands.c \
	default.c \
	dir.c \
	expand.c \
	file.c \
	function.c \
	implicit.c \
	job.c \
	misc.c \
	remake.c \
	rule.c \
	signame.c \
	version.c \
	vpath.c \
	remote-stub.c


include $(PATH_KBUILD)/footer.kmk


#
# Use checked in config.h instead of running ./Configure for it.
#
config.h.$(BUILD_TARGET) := config.h.$(BUILD_TARGET)
$(PATH_TARGET)/config.h: $(config.h.$(BUILD_TARGET))
	$(MKDIR) -p $(dir $@)
	$(CP) $^ $@

#
# Some missing headers.
#
$(PATH_TARGET)/fts.h: kmkbuiltin/ftsfake.h | $(call DIRDEP,$(PATH_TARGET))
	$(CP) $^ $@

$(PATH_TARGET)/unistd.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@

$(PATH_TARGET)/sysexits.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@

$(PATH_TARGET)/inttypes.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@

$(PATH_TARGET)/paths.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@

$(PATH_TARGET)/pwd.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@

$(PATH_TARGET)/grp.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@


#
# Some tests.
#
parallel: parallel_1 parallel_2 parallel_3 parallel_4 parallel_5
parallel_1 parallel_2 parallel_3 parallel_4 parallel_5:
	echo $@_start ; sleep 1; echo $@_done

test:
	echo "1"
	echo "2"
	echo "3"
	echo "4"


#
# Shell execution tests.
#
test_shell: test_shell_quoting test_shell_double_quoting test_shell_newline

# shell double and single quoting check (was busted on windows in 3.81).
test_shell_quoting:
	$(ECHO_EXT) "double quoted sTrInG"
	$(ECHO_EXT) "double quoted sTrInG" | $(SED_EXT) -e "s/sTrInG/string/g"
	$(ECHO_EXT) 'single quoted sTrInG' | $(SED_EXT) -e 's/sTrInG/string/g'
	$(ECHO) "This string should not be printed with double quotes."
	$(ECHO) 'This string should not be printed with single quotes.'
	( echo "  #define PWD \"`pwd`\""; )

test_shell_double_quoting:
	$(ECHO_EXT) "foo foo foo" | $(SED_EXT) -e \
		"s/foo/$@/" -e \
		"s/foo/works/" \
		-e "s/foo/\!/"

test_shell_double_quoting2:
	$(ECHO_EXT) "foo foo foo" | $(SED_EXT) -e \
		"s/foo/$@/" -e \
		"s/foo/works/" \
		-e\
		"s/foo/\!/"

# when using batch mode shell, the newline got escaped twice and spoiling everything.
test_shell_newline:
	$(ECHO_EXT) "foo foo foo" | $(SED_EXT) -e \
		's/foo/$@/' -e \
		's/foo/works/' \
		-e 's/foo/\!/'


test_stack:
	$(MAKE) -f testcase-stack.kmk

test_math:
	$(MAKE) -f testcase-math.kmk


test_all:	test_math test_stack test_shell

