# $Id$
## @file
# kmk / GNU Make
#

#
# Copyright (c) 2004-2008 knut st. osmundsen <bird-kBuild-spam@anduin.net>
#
# This file is part of kBuild.
#
# kBuild is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# kBuild is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with kBuild; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
#


DEPTH = ../..
include $(PATH_KBUILD)/header.kmk


#
# Template for kmk and the kmk_* binaries in this makefile.
#
TEMPLATE_BIN-KMK = Template for src/gmake binaries
TEMPLATE_BIN-KMK_EXTENDS = BIN
TEMPLATE_BIN-KMK_DEFS = \
	HAVE_CONFIG_H \
	$(TEMPLATE_BIN_DEFS) \
	KBUILD_SVN_REV=$(KBUILD_SVN_REV)
TEMPLATE_BIN-KMK_DEPS = $(PATH_TARGET)/config.h
TEMPLATE_BIN-KMK_CLEAN = $(TEMPLATE_BIN-KMK_DEPS)
TEMPLATE_BIN-KMK_DEPS.solaris = \
	$(PATH_TARGET)/fts.h \
	$(PATH_TARGET)/paths.h
TEMPLATE_BIN-KMK_CLEAN.solaris = $(TEMPLATE_BIN-KMK_DEPS.solaris)
TEMPLATE_BIN-KMK_DEPS.win     = \
	$(PATH_TARGET)/fts.h \
	$(PATH_TARGET)/sysexits.h \
	$(PATH_TARGET)/unistd.h \
	$(PATH_TARGET)/paths.h \
	$(PATH_TARGET)/grp.h \
	$(PATH_TARGET)/pwd.h \
	$(PATH_TARGET)/inttypes.h
TEMPLATE_BIN-KMK_CFLAGS.win.amd64 = $(TEMPLATE_BIN_CFLAGS.win.amd64) -wd4244 -wd4267
TEMPLATE_BIN-KMK_CLEAN.win = $(TEMPLATE_BIN-KMK_DEPS.win)
TEMPLATE_BIN-KMK_INCS = $(PATH_TARGET) . $(TEMPLATE_BIN_INCS)
TEMPLATE_BIN-KMK_INCS.darwin = glob
TEMPLATE_BIN-KMK_INCS.freebsd = glob
TEMPLATE_BIN-KMK_INCS.solaris = glob
TEMPLATE_BIN-KMK_LIBS = $(TEMPLATE_BIN_LIBS) $(TARGET_kmkmissing) $(LIB_KUTIL)
ifdef ELECTRIC_HEAP # for electric heap (see electric.c) - windows only.
ifeq ($(KBUILD_TARGET),win)
 TEMPLATE_BIN-KMK_CFLAGS = $(TEMPLATE_BIN_CFLAGS) /FI$(PATH_CURRENT)/electric.h -DELECTRIC_HEAP=1
else
 TEMPLATE_BIN-KMK_CFLAGS = $(TEMPLATE_BIN_CFLAGS) -include $(PATH_CURRENT)/electric.h -DELECTRIC_HEAP=1
endif
endif


#
# A library containing the missing features needed by kmk and the
# kmk_* binaries. Saves a bit of work later on.
#
LIBRARIES += kmkmissing
kmkmissing_TEMPLATE = BIN-KMK
kmkmissing_DEFS = KMK
kmkmissing_NOINST = 1
kmkmissing_SOURCES = \
	kmkbuiltin/err.c \
	kmkbuiltin/setmode.c \
	kmkbuiltin/strmode.c \
	kmkbuiltin/kbuild_version.c \
	getopt.c \
	getopt1.c \
	electric.c

kmkmissing_SOURCES.darwin = \
	kmkbuiltin/darwin.c \
	glob/glob.c \
	glob/fnmatch.c

kmkmissing_SOURCES.freebsd = \
	glob/glob.c \
	glob/fnmatch.c

kmkmissing_SOURCES.linux += \
	kmkbuiltin/strlcpy.c

kmkmissing_SOURCES.solaris = \
	kmkbuiltin/strlcpy.c \
	kmkbuiltin/solfakes.c \
	kmkbuiltin/fts.c \
	glob/glob.c \
	glob/fnmatch.c

kmkmissing_SOURCES.win += \
	kmkbuiltin/strlcpy.c \
	kmkbuiltin/mscfakes.c \
	kmkbuiltin/fts.c \
	glob/glob.c \
	glob/fnmatch.c \
	getloadavg.c \
	w32/subproc/misc.c \
	w32/subproc/sub_proc.c \
	w32/subproc/w32err.c \
	w32/compat/dirent.c \
	w32/pathstuff.c

#
# kmk
#
PROGRAMS += kmk

kmk_TEMPLATE = BIN-KMK

kmk_DEFS = \
	NO_ARCHIVES \
	EXPERIMENTAL \
	CONFIG_WITH_TOUPPER_TOLOWER \
	CONFIG_WITH_EXPLICIT_MULTITARGET \
	CONFIG_WITH_PREPEND_ASSIGNMENT \
	CONFIG_WITH_LOCAL_VARIABLES \
	\
	KMK \
	KMK_HELPERS \
	VARIABLE_HASH \
	CONFIG_NO_DEFAULT_SUFFIXES \
	CONFIG_NO_DEFAULT_PATTERN_RULES	\
	CONFIG_NO_DEFAULT_TERMINAL_RULES \
	CONFIG_NO_DEFAULT_SUFFIX_RULES \
	CONFIG_NO_DEFAULT_VARIABLES \
	CONFIG_WITH_EXTENDED_NOTPARALLEL \
	CONFIG_WITH_INCLUDEDEP \
	CONFIG_WITH_VALUE_LENGTH \
	CONFIG_WITH_RSORT \
	CONFIG_WITH_ABSPATHEX \
	CONFIG_WITH_COMPARE \
	CONFIG_WITH_STACK \
	CONFIG_WITH_MATH \
	CONFIG_WITH_XARGS \
	CONFIG_WITH_NANOTS \
	CONFIG_WITH_SET_CONDITIONALS \
	CONFIG_WITH_DATE \
	CONFIG_WITH_FILE_SIZE \
	CONFIG_WITH_WHICH \
	CONFIG_WITH_EVALPLUS \
	CONFIG_WITH_MAKE_STATS \
	CONFIG_WITH_COMMANDS_FUNC \
	CONFIG_PRETTY_COMMAND_PRINTING \
	\
	KBUILD_HOST=\"$(KBUILD_TARGET)\" \
	KBUILD_HOST_ARCH=\"$(KBUILD_TARGET_ARCH)\" \
	KBUILD_HOST_CPU=\"$(KBUILD_TARGET_CPU)\"
kmk_DEFS.x86 = CONFIG_WITH_OPTIMIZATION_HACKS
kmk_DEFS.amd64 = CONFIG_WITH_OPTIMIZATION_HACKS
kmk_DEFS.win = CONFIG_NEW_WIN32_CTRL_EVENT

kmk_SOURCES = \
	main.c \
	read.c \
	hash.c \
	strcache.c \
	variable.c \
	ar.c \
	arscan.c \
	commands.c \
	default.c \
	dir.c \
	expand.c \
	file.c \
	function.c \
	implicit.c \
	job.c \
	misc.c \
	remake.c \
	rule.c \
	signame.c \
	version.c \
	vpath.c \
	remote-stub.c \
	kbuild.c

#
# kmkbuiltin commands
#
kmk_DEFS += CONFIG_WITH_KMK_BUILTIN
kmk_LIBS += $(LIB_KUTIL) $(LIB_KDEP)
kmk_SOURCES += \
	kmkbuiltin.c \
	kmkbuiltin/append.c \
	kmkbuiltin/cat.c \
	kmkbuiltin/cmp.c \
	kmkbuiltin/cmp_util.c \
	kmkbuiltin/cp.c \
	kmkbuiltin/cp_utils.c \
	kmkbuiltin/echo.c \
	kmkbuiltin/install.c \
	kmkbuiltin/kDepIDB.c \
	kmkbuiltin/md5sum.c \
	kmkbuiltin/mkdir.c \
	kmkbuiltin/mv.c \
	kmkbuiltin/ln.c \
	kmkbuiltin/printf.c \
	kmkbuiltin/rm.c \
	kmkbuiltin/rmdir.c \
	kmkbuiltin/test.c \

## @todo kmkbuiltin/redirect.c

## Some profiling
#kmk_SOURCES += kbuildprf.c
#kmk_DEFS += open=prf_open read=prf_read lseek=prf_lseek close=prf_close
##kmk_DEFS += KMK_PRF=1
##kmkmissing_DEFS += KMK_PRF=1

#
# Standalone kmkbuiltin commands.
#
PROGRAMS += \
	kmk_append \
	kmk_cat \
	kmk_cp \
	kmk_cmp \
	kmk_echo \
	kmk_md5sum \
	kmk_mkdir \
	kmk_mv \
	kmk_install \
	kmk_ln \
	kmk_printf \
	kmk_redirect \
	kmk_rm \
	kmk_rmdir \
	kmk_test \
	kDepIDB \

kmk_append_TEMPLATE = BIN-KMK
kmk_append_DEFS = kmk_builtin_append=main
kmk_append_INCS = .
kmk_append_SOURCES = \
	kmkbuiltin/append.c

kmk_cat_TEMPLATE = BIN-KMK
kmk_cat_DEFS = kmk_builtin_cat=main
kmk_cat_SOURCES = \
	kmkbuiltin/cat.c

kmk_cmp_TEMPLATE = BIN-KMK
kmk_cmp_DEFS = kmk_builtin_cmp=main
kmk_cmp_SOURCES = \
	kmkbuiltin/cmp.c \
	kmkbuiltin/cmp_util.c

kmk_cp_TEMPLATE = BIN-KMK
kmk_cp_DEFS = kmk_builtin_cp=main
kmk_cp_SOURCES = \
	kmkbuiltin/cp.c \
	kmkbuiltin/cp_utils.c \
	kmkbuiltin/cmp_util.c

kmk_echo_TEMPLATE = BIN-KMK
kmk_echo_DEFS = kmk_builtin_echo=main
kmk_echo_SOURCES = \
	kmkbuiltin/echo.c

kmk_install_TEMPLATE = BIN-KMK
kmk_install_DEFS = kmk_builtin_install=main
kmk_install_SOURCES = \
	kmkbuiltin/install.c

kmk_ln_TEMPLATE = BIN-KMK
kmk_ln_DEFS = kmk_builtin_ln=main
kmk_ln_SOURCES = \
	kmkbuiltin/ln.c

kmk_mkdir_TEMPLATE = BIN-KMK
kmk_mkdir_DEFS = kmk_builtin_mkdir=main
kmk_mkdir_SOURCES = \
	kmkbuiltin/mkdir.c

kmk_md5sum_TEMPLATE = BIN-KMK
kmk_md5sum_DEFS = kmk_builtin_md5sum=main
kmk_md5sum_SOURCES = \
	kmkbuiltin/md5sum.c
kmk_md5sum_LIBS = $(LIB_KUTIL)

kmk_mv_TEMPLATE = BIN-KMK
kmk_mv_DEFS = kmk_builtin_mv=main
kmk_mv_SOURCES = \
	kmkbuiltin/mv.c

kmk_printf_TEMPLATE = BIN-KMK
kmk_printf_DEFS = kmk_builtin_printf=main
kmk_printf_SOURCES = \
	kmkbuiltin/printf.c

kmk_rm_TEMPLATE = BIN-KMK
kmk_rm_DEFS = kmk_builtin_rm=main
kmk_rm_SOURCES = \
	kmkbuiltin/rm.c

kmk_redirect_TEMPLATE = BIN-KMK
kmk_redirect_DEFS = kmk_builtin_redirect=main
kmk_redirect_SOURCES = \
	kmkbuiltin/redirect.c

kmk_rmdir_TEMPLATE = BIN-KMK
kmk_rmdir_DEFS = kmk_builtin_rmdir=main
kmk_rmdir_SOURCES = \
	kmkbuiltin/rmdir.c

kmk_test_TEMPLATE = BIN-KMK
kmk_test_DEFS = kmk_builtin_test=main
kmk_test_SOURCES = \
	kmkbuiltin/test.c

kDepIDB_TEMPLATE = BIN-KMK
kDepIDB_DEFS = kmk_builtin_kDepIDB=main
kDepIDB_INCS = .
kDepIDB_LIBS = $(LIB_KDEP)
kDepIDB_SOURCES = \
	kmkbuiltin/kDepIDB.c


#
# kmk_gmake - almost plain GNU Make.
#
PROGRAMS += kmk_gmake

kmk_gmake_TEMPLATE = BIN-KMK
kmk_gmake_DEFS = \
	HAVE_CONFIG_H \
	NO_ARCHIVES \
	CONFIG_WITH_TOUPPER_TOLOWER \
	EXPERIMENTAL

kmk_gmake_SOURCES = \
	main.c \
	read.c \
	hash.c \
	strcache.c \
	variable.c \
	ar.c \
	arscan.c \
	commands.c \
	default.c \
	dir.c \
	expand.c \
	file.c \
	function.c \
	implicit.c \
	job.c \
	misc.c \
	remake.c \
	rule.c \
	signame.c \
	version.c \
	vpath.c \
	remote-stub.c


include $(FILE_KBUILD_FOOTER)


#
# Use checked in config.h instead of running ./Configure for it.
#
config.h.$(KBUILD_TARGET) := config.h.$(KBUILD_TARGET)
$(PATH_TARGET)/config.h: $(config.h.$(KBUILD_TARGET))
	$(MKDIR) -p $(dir $@)
	$(CP) $^ $@

#
# Some missing headers.
#
$(PATH_TARGET)/fts.h: kmkbuiltin/ftsfake.h | $(call DIRDEP,$(PATH_TARGET))
	$(CP) $^ $@

$(PATH_TARGET)/unistd.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@

$(PATH_TARGET)/sysexits.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@

$(PATH_TARGET)/inttypes.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@

$(PATH_TARGET)/paths.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@

$(PATH_TARGET)/pwd.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@

$(PATH_TARGET)/grp.h: | $(call DIRDEP,$(PATH_TARGET))
	$(ECHO_EXT) > $@


#
# Some tests.
#
parallel: parallel_1 parallel_2 parallel_3 parallel_4 parallel_5
parallel_1 parallel_2 parallel_3 parallel_4 parallel_5:
	echo $@_start ; sleep 1; echo $@_done

test:
	echo "1"
	echo "2"
	echo "3"
	echo "4"


#
# Shell execution tests.
#
test_shell: test_shell_quoting test_shell_double_quoting test_shell_newline

# shell double and single quoting check (was busted on windows in 3.81).
test_shell_quoting:
	$(ECHO_EXT) "double quoted sTrInG"
	$(ECHO_EXT) "double quoted sTrInG" | $(SED_EXT) -e "s/sTrInG/string/g"
	$(ECHO_EXT) 'single quoted sTrInG' | $(SED_EXT) -e 's/sTrInG/string/g'
	$(ECHO) "This string should not be printed with double quotes."
	$(ECHO) 'This string should not be printed with single quotes.'
	( echo "  #define PWD \"`pwd`\""; )

test_shell_double_quoting:
	$(ECHO_EXT) "foo foo foo" | $(SED_EXT) -e \
		"s/foo/$@/" -e \
		"s/foo/works/" \
		-e "s/foo/\!/"

test_shell_double_quoting2:
	$(ECHO_EXT) "foo foo foo" | $(SED_EXT) -e \
		"s/foo/$@/" -e \
		"s/foo/works/" \
		-e\
		"s/foo/\!/"

# when using batch mode shell, the newline got escaped twice and spoiling everything.
test_shell_newline:
	$(ECHO_EXT) "foo foo foo" | $(SED_EXT) -e \
		's/foo/$@/' -e \
		's/foo/works/' \
		-e 's/foo/\!/'


test_stack:
	$(MAKE) -f testcase-stack.kmk

test_math:
	$(MAKE) -f testcase-math.kmk

test_if1of:
	$(MAKE) -f testcase-if1of.kmk

test_local:
	$(MAKE) -f testcase-local.kmk

test_30_continued_on_failure_worker:
	this_executable_does_not_exist.exe
	echo "We shouldn't see this..."

test_30_continued_on_failure:
	$(MAKE) -f $(MAKEFILE) test_30_continued_on_failure_worker; \
	RC=$$?; \
	if test $${RC} -ne 2; then \
		echo "$@: FAILED - exit code $${RC} instead of 2."; \
		exit 1; \
	else \
		echo "$@: SUCCESS"; \
	fi


test_all:	test_math test_stack test_shell test_if1of test_local test_30_continued_on_failure

